
#### 분리
- SOC(Seperation Of Concern) : 관심사의 분리
- 같은 관심사(주제)는 한 곳으로 분리되어 존재해야 함
- 쉽게 말해서 동일한 기능을 하는 부분들이 여기저기 중복해서 나타나게 될 경우 고칠 때 일일이 다 확인하며 고쳐야 하므로 불편하기 때문에 관심사의 분리가 필요한 것

`해결`
- 같은 기능을 하는 부분들을 하나의 메소드로 만들어서 해당 메소드를 호출하는 방식으로 바꾸게 됨 --> 이렇게 해결하는 기법을 메소드 추출(Method Extraction)이라고 함
- 위와 같이 입력과 출력은 바뀌지 않고(즉, 하는 역할은 변하지 않음) 코드를 조금 더 효율적으로 만들어주는 과정을 통칭해서 Refactoring이라고 함(메소드 추출은 Refactoring의 한 기법이라고 할 수 있음)

step1 에서 step2로 Refactoring(코드 참고)



#### 확장
- 만약 내가 지금 만든 UserDao 클래스를 판매하려고 한다면(당연히 Source Code를 생으로 제공하는 것이 아니라 컴파일된 상태 즉, .class 파일의 형태로 판매를 하게 됨) 해당 클래스는 확장성이 있는 코드라고 보기 어려움
- 왜냐하면 현재 작성되어 있는 클래스 안에는 연결될 DB정보를 포함한 url, Id, pw가 포함되어 있는데 컴파일된 후에는 해당 정보를 수정할 수 없게 됨 --> 그렇게 될 경우 여러 종류의 DB, ID, PW를 연결할 수 없음

`해결`
- 변할 여지가 있는 부분을 추상화시켜야 함
- 추상화 - 고정의 반대 개념으로 구체적인 내용은 명시하지 않는 것을 의미함
- 추상화를 함으로써 사용자에 따라 다르게 정의해서 사용할 수 있게 됨(확장성이 가미됨)
- 부모 클래스에 바뀔 수 있는 부분을 추상 메소드로 선언해둔 후 상속받게 하여 해당 메소드를 재정의해서 사용하도록 구현

step2 에서 step3로 Refactoring(코드 참고)



### IoC(Inversion of Control) : 제어의 역전
- Spring는 IoC Container임 = 제어가 역전되어 개발자가 제어하던 일을 수행하는 Container
- 객체간의 관계를 맺어준다 = 한 객체에서 다른 객체의 쓰임이 필요할 경우 서로 연결해준다.
- 이 IoC Container(편하게 Application context나 Spring container라고도 부름)를 객체간의 관계를 맺어준다고 하여 설계도라고 부름
- Component : 나머지 비즈니스로직을 수행하는 부분을 말함

- (step7) 코드에서 봤을 때 기존에는 main 메소드 안을 내가 직접 정의해서 실행했던 것처럼 제어의 흐름을 내가 주도했음
- 하지만 main에서 일일이 어떤 객체를 만들어서 주입할지 정해주는 것이 아니라 DaoFactory라는 Class에서 작성했던 것과 같이 특정  Object에 의해 알아서 설정 객체(설정정보를 담는 놈도 객체로 자동으로 만들어줌)가 선택되고 알아서 객체가 만들어져 반환되는 것과 같은 현상을 제어의 역전(IoC)이라고 함

ex)Servlet에서 request를 보내면 url에 따라 Servlet Container가 알아서 해당 Servlet클래스를 찾아주고 그 Servlet클래스를 알아서 객체로 만들어주는 것처럼 코드의 흐름을 내가 제어하는 것이 아닌 Container같은 애들에 의해 제어(주도)되는 것을 제어하는 주체가 바뀌었다고 해서 제어의 역전이라고 함 / 전에 썼던 커넥션 풀 역시 제어의 역전이 가미되었다고 할 수 있음

Annotation : 정해져 있는 키워드들이 있지만 개발자가 직접 만들 수도 있음
번역은 '주석' 이라고 해석되지만 실제로 주석 역할을 하는 건 아님
--> 로직에는 영향을 미치지 않지만, 프로그램 구조에는 영향을 미침



### Spring의 대표적인 기능
- Spring은 상당히 방대한 기능을 가지고 있음
- 핵심적인 기능 -> Bean factory 기능 : Bean이라는 객체를 계속 만들어주는 기능
- 이 기능을 Application Context라고 부름 / 그래서 앞서 IoC Container를 이렇게 부르기도 한다고 설명했는데 사실은 기능의 이름인 것임 다만, 그 기능이 핵심적인 기능이기 때문에 그냥 뭉뚱그려서 IoC Container를 Application Context라고 부르기도 하는 것임
- Bean : Spring이 제어권을 가지고 직접 만들고 관계를 부여하는(= 주입 따위를 하는) 객체를 Bean이라고 함 -> 만들어진 Bean은 Application Context가 Singleton으로 생성해서 관리하게 된다.(단, default가 singleton인 것이지 다르게 관리되도록 설정해줄 수도 있다 ex - protoType)

- 그런데 Application Context가 Bean을 만들기 위해서는 해당 Bean에 대한 설정정보가 필요함(어떤 클래스에 의해 만들어지고 언떤 객체와 연결될지에 대한 설정정보)
1. XMl에서 해줄 수 있음
- 이게 기본적인 방법이다. 하지만 하나의 파일에 작성하는 방식이므로 프로젝트의 크기가 커지면 당연히 설정정보들도 많아지므로 복잡하다는 단점과 한눈에 설정정보를 볼 수 있다는 장점이 공존하게 된다.
2. Annotation
- 이 방식은 한눈에 보기는 힘들다(여기저기 산재되어 있으니까)는 단점이 있지만 보다 간편하다는 장점이 있다.
둘 다 수동으로 등록하는 방식임 (자동은 AutoWired 같은 게 따로 있음)

( ★ 그림 21 꼭 참고 ★ )  
Bean을 등록하기 위한 방법(Application Context에 인식시키는 방법)

수동으로 등록하는 법 중 하나로 annotation을 이용할 것
1. 해당 클래스를 인스턴스로 만들어 return하는 메소드가 필요함
2. 그 메소드 위에 @Bean이라는 어노테이션을 붙임
3. 그리고 해당 메소드를 가진 클래스는 @Configuration이라는 어노테이션이 붙어야 함

- return되는 인스턴스의 생성자명(클래스명이랑 똑같음)을 Bean이 될 Class의 이름으로 인식함
- 이 메소드명이 Bean의 id가 됨 즉, 이 메소드의 이름은 유일해야 함(그래서 오버로딩 같은 거 하면 안 됨)
- 
![](Pasted%20image%2020230704074354.png)
- 이런 식으로 정의해주고 나면 Spring Container(=Application Context)는 @Configuration이라는 어노테이션이 붙은 class를 Bean으로 등록시킴
- 그리고 해당 클래스를 해석해서 @Bean이 붙은 메소드가 new 클래스명()해서 return하게 써준 구문에서 나온 클래스를 Bean으로 만듬
- 결국 해당 클래스와 그 클래스 안에 있는 메소드들이 return하는 놈들을 모두 Bean으로 만든다는 얘기인 것이지.

