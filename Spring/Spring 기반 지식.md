
#### 분리
- SOC(Seperation Of Concern) : 관심사의 분리
- 같은 관심사(주제)는 한 곳으로 분리되어 존재해야 함
- 쉽게 말해서 동일한 기능을 하는 부분들이 여기저기 중복해서 나타나게 될 경우 고칠 때 일일이 다 확인하며 고쳐야 하므로 불편하기 때문에 관심사의 분리가 필요한 것

`해결`
- 같은 기능을 하는 부분들을 하나의 메소드로 만들어서 해당 메소드를 호출하는 방식으로 바꾸게 됨 --> 이렇게 해결하는 기법을 메소드 추출(Method Extraction)이라고 함
- 위와 같이 입력과 출력은 바뀌지 않고(즉, 하는 역할은 변하지 않음) 코드를 조금 더 효율적으로 만들어주는 과정을 통칭해서 Refactoring이라고 함(메소드 추출은 Refactoring의 한 기법이라고 할 수 있음)

step1 에서 step2로 Refactoring(코드 참고)



#### 확장
- 만약 내가 지금 만든 UserDao 클래스를 판매하려고 한다면(당연히 Source Code를 생으로 제공하는 것이 아니라 컴파일된 상태 즉, .class 파일의 형태로 판매를 하게 됨) 해당 클래스는 확장성이 있는 코드라고 보기 어려움
- 왜냐하면 현재 작성되어 있는 클래스 안에는 연결될 DB정보를 포함한 url, Id, pw가 포함되어 있는데 컴파일된 후에는 해당 정보를 수정할 수 없게 됨 --> 그렇게 될 경우 여러 종류의 DB, ID, PW를 연결할 수 없음

`해결`
- 변할 여지가 있는 부분을 추상화시켜야 함
- 추상화 - 고정의 반대 개념으로 구체적인 내용은 명시하지 않는 것을 의미함
- 추상화를 함으로써 사용자에 따라 다르게 정의해서 사용할 수 있게 됨(확장성이 가미됨)
- 부모 클래스에 바뀔 수 있는 부분을 추상 메소드로 선언해둔 후 상속받게 하여 해당 메소드를 재정의해서 사용하도록 구현

step2 에서 step3로 Refactoring(코드 참고)



### IoC(Inversion of Control) : 제어의 역전
- Spring는 IoC Container임 = 제어가 역전되어 개발자가 제어하던 일을 수행하는 Container
- 객체간의 관계를 맺어준다 = 한 객체에서 다른 객체의 쓰임이 필요할 경우 서로 연결해준다.
- 이 IoC Container(편하게 Application context나 Spring container라고도 부름)를 객체간의 관계를 맺어준다고 하여 설계도라고 부름
- Component : 나머지 비즈니스로직을 수행하는 부분을 말함
- 사실 IoC Container는 Application Context라는 인터페이스의 구현체임

- (step7) 코드에서 봤을 때 기존에는 main 메소드 안을 내가 직접 정의해서 실행했던 것처럼 제어의 흐름을 내가 주도했음
- 하지만 main에서 일일이 어떤 객체를 만들어서 주입할지 정해주는 것이 아니라 DaoFactory라는 Class에서 작성했던 것과 같이 특정  Object에 의해 알아서 설정 객체(설정정보를 담는 놈도 객체로 자동으로 만들어줌)가 선택되고 알아서 객체가 만들어져 반환되는 것과 같은 현상을 제어의 역전(IoC)이라고 함

ex)Servlet에서 request를 보내면 url에 따라 Servlet Container가 알아서 해당 Servlet클래스를 찾아주고 그 Servlet클래스를 알아서 객체로 만들어주는 것처럼 코드의 흐름을 내가 제어하는 것이 아닌 Container같은 애들에 의해 제어(주도)되는 것을 제어하는 주체가 바뀌었다고 해서 제어의 역전이라고 함 / 전에 썼던 커넥션 풀 역시 제어의 역전이 가미되었다고 할 수 있음

Annotation : 정해져 있는 키워드들이 있지만 개발자가 직접 만들 수도 있음
번역은 '주석' 이라고 해석되지만 실제로 주석 역할을 하는 건 아님
--> 로직에는 영향을 미치지 않지만, 프로그램 구조에는 영향을 미침



### Spring의 대표적인 기능
- Spring은 상당히 방대한 기능을 가지고 있음
- 핵심적인 기능 -> Bean factory 기능 : Bean이라는 객체를 계속 만들어주는 기능
- Bean : Spring이 제어권을 가지고 직접 만들고 관계를 부여하는(= 주입 따위를 하는) 객체를 Bean이라고 함 -> 만들어진 Bean은 Application Context가 Singleton으로 생성해서 관리하게 된다.(단, default가 singleton인 것이지 다르게 관리되도록 설정해줄 수도 있다 ex - protoType)

- 그런데 Application Context가 Bean을 만들기 위해서는 해당 Bean에 대한 설정정보가 필요함(어떤 클래스에 의해 만들어지고 언떤 객체와 연결될지에 대한 설정정보)
1. XMl에서 해줄 수 있음
- 이게 기본적인 방법이다. 하지만 하나의 파일에 작성하는 방식이므로 프로젝트의 크기가 커지면 당연히 설정정보들도 많아지므로 복잡하다는 단점과 한눈에 설정정보를 볼 수 있다는 장점이 공존하게 된다.
2. Annotation
- 이 방식은 한눈에 보기는 힘들다(여기저기 산재되어 있으니까)는 단점이 있지만 보다 간편하다는 장점이 있다.
둘 다 수동으로 등록하는 방식임 (자동은 AutoWired 같은 게 따로 있음)

( ★ 그림 21 꼭 참고 ★ )  
Bean을 등록하기 위한 방법(Application Context에 인식시키는 방법)

수동으로 등록하는 법 중 하나로 annotation을 이용할 것
1. 해당 클래스를 인스턴스로 만들어 return하는 메소드가 필요함
2. 그 메소드 위에 @Bean이라는 어노테이션을 붙임
3. 그리고 해당 메소드를 가진 클래스는 @Configuration이라는 어노테이션이 붙어야 함

- return되는 인스턴스의 생성자명(클래스명이랑 똑같음)을 Bean이 될 Class의 이름으로 인식함
- 이 메소드명이 Bean의 id가 됨 즉, 이 메소드의 이름은 유일해야 함(그래서 오버로딩 같은 거 하면 안 됨)
- 
![](Pasted%20image%2020230704074354.png)
- 이런 식으로 정의해주고 나면 Spring Container(=Application Context)는 @Configuration이라는 어노테이션이 붙은 class를 Bean으로 등록시킴
- 그리고 해당 클래스를 해석해서 @Bean이 붙은 메소드가 new 클래스명()해서 return하게 써준 구문에서 나온 클래스를 Bean으로 만듬
- 결국 해당 클래스와 그 클래스 안에 있는 메소드들이 return하는 놈들을 모두 Bean으로 만든다는 얘기인 것이지.

metadata : 메타데이터는 데이터의 대한 정보라고 할 수 있음(메타정보라고도 부름)
Ex) 사진 파일일 경우 파일 자체는 이미지라는 데이터 뿐만 아니라 메타데이터라고 불리는 사진이름, 촬영날짜, 사진크기 등의 정보도 가지고 있음

API : 일반적으로 프로그램을 사용할 수 있도록 하는 규약을 말함(흔히 url처럼 생긴 API도 해당 url이나 key 이런 걸 다 작성해주고 거기로 요청을 보내야 한다는 규약이 있는 것이라고 볼 수 있음) 또한, 메소드 같은 것을 API라고 부르기도 함

빌드도구 : 소스코드에서 실행 가능한 프로그램(application)으로 만드는 과정을 자동화하는 도구
- 역할
1. 의존성 관리 : 외부 라이브러리나 모듈을 자동으로 다운로드하고 관리해줌
Ex) 스프링에서 pom.xml에 dependency를 추가해주면 해당 dependency를 자동으로 다운로드하고 관리함
2. 컴파일 : 컴파일러를 통해 소스코드를 컴파일하는 과정을 해줌(이 과정은 빌드도구를 사용하지 않더라도 코드 실행 시 원래 자동으로 되기는 했음 하지만, 빌드 도구는 여러 파일에 대해서도 모두 자동으로 컴파일을 해줌
Ex) 실행하면 내가 일일이 실행하지 않았는데도 Controller, Service, Dao 등 개별적인 클래스들이 모두 컴파일되는 것을 예로 들 수 있음
3. 테스트 실행 : @Test를 붙인 메소드를 테스트 단계에서 자동으로 실행하고 결과를 반환해줌
4. 패키징 : 프로젝트를 하나의 실행 가능한 파일로 묶어줌
Ex) '.class'파일들과 필요한 리소스들을 하나의 jar나 war 파일로 묶어줌


jar / war : 둘 다 여러 파일을 하나의 아카이브 파일(여러 파일이나 디렉토리를 하나의 파일로 묶어놓은 형태)로 만들기 위해 사용되는 파일의 형태
- jar : 일반적인 Java 애플리케이션을 위한 패키징 포맷 /Java 클래스 파일, 메타데이터, 리소스 파일(이미지, 텍스트 파일 등)을 포함할 수 있음
- war : 웹 애플리케이션을 위한 패키징 포맷 /Java 클래스 파일, 메타데이터, 리소스 파일, JSP(Java Server Pages), 서블릿, HTML, JavaScript, CSS 등의 웹 리소스를 포함할 수 있음

war 파일은 웹서버나 서블릿 컨테이너에 의해 자동으로 압축이 해제되어 실행됨

