- @RequestBody 어노테이션은 일반적으로 텍스트 데이터를 처리하는 데 사용됨 즉, 텍스트 데이터를 받아 Vo의 필드의 값으로 넣고 해당 vo 클래스를 객체로 만드는 역할을 수행한는 것임
--> 그래서 @RequestBody로는 파일데이터를 받아 처리할 수 없는 것임

- 스프링에서 객체형태가 아닌 primitive Type의 매개변수로 데이터를 받는 경우 @RequestParam이 생략되어 있는 것임 근데 @RequestParam은 url뒤에 붙어오는 쿼리스트링 형태의 데이터를 받기 위한 어노테이션임(그래서 requestBody에 담겨 오는 데이터를 이런 primitive Type변수로 받기 위해선 이 매개변수 앞에 @RequestBody를 명시해줘야 함)

- axios의 params로 데이터를 넘기는 경우에는 url뒤에 붙어서 가게 됨 --> 이때는 POST던 PUT이던 다 requestBody가 아니라 url에 붙어서 온 데이터를 읽게 됨(즉, 둘 다 일반적으로 requestBody로 받는 것이지 url으로 넘어오는 데이터를 받지 못하는 것은 아님)


## DTO와 VO의 차이

#### DTO
1. 비즈니스 로직이 없는 순수한 데이터 객체
2. 보통 여러 계층 간의 데이터 전달을 위해 사용됨
3. 데이터를 전송하기 위한 객체로, 여러 필드를 가지고 있음
4. 일반적으로 외부에서 내부 시스템으로 데이터를 전송할 때 사용

#### VO
1. 변경이 불가능한 객체
2. 비즈니스 로직을 포함하는 객체
3. 보통 UI 또는 Presentation 계층에서 사용됨
4. 일반적으로 내부시스템에서 UI로 데이터를 전송할 때 사용

Client에서 파라미터를 넘길 때 vo형태의 매개변수를 작성할 경우 Command객체(= 해당 VO)가 먼저 생성되고 넘어오는 데이터를 setter를 통해 해당 객체 안 필드에 저장하게 됨 죽, 객체가 먼저 생성되기 때문에 default 생성자가 먼저 호출됨

정리하면 DTO는 비즈니스 로직 없이 순수한 데이터만 가진 객체이고, VO는 비즈니스 로직을 포함하며 변경이 불가능한 객체를 말한다.

v-for의 key속성은 해당 행의 데이터를 삭제할 시 해당 key속성의 값을 통해 조금 더 효율적인 처리를 하기 위해 잡는 것이라고 함(한 컴포넌트 안에서 이 key값은 중복되면 안 됨 v-for가 여러 번 사용될 경우 주의 --> value+100 이런 식으로 중복되지만 않게 설정해주면 해결)

v-for = "value in 3" 과 같이 작성하면 value가 기본 for문처럼 1, 2, 3.. 이런 식으로 찍히게 됨(3번 반복하게 된다는 말)

- SqlSession은 dataSource가 관리하는 커넥션 풀의 Connection 객체를 사용하여 만들게 된다.
- 스프링 3.3부터는 생성자 위에 Autowired를 생략해도 자동주입이 가능하다. 그리고 요즘은 생성자 주입이 권장된다고 한다.


- throws Exception는 클래스 레벨에서는 선언이 안 됨