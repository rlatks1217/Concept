
### System.in
- bite Stream으로서 1바이트 크기의 데이터 단위(영어 기준으로 보통 1글자가 1바이트임/한글을 1글자가 2바이트)를 받을 수 있음
- 이것을 한글 또한 한 글자 단위로 받을 수 있도록 스트림을 변환해주기 위해 InputStreamReader를 사용함
- 이 데이터를 받은 다음에 더 효울적으로 읽기 위해(예를 들면 한 글자가 아니라 한 줄씩 읽기 위해) BufferedReader를 사용하게 됨
- 그냥 bite Stream을 사용하게 될 경우 bite 단위로 read()를 통해 입력을 받게 됨(이 때 해당 메소드가 반환하는 값은 입력값의 갯수를 반환함)
- 물론 이 메소드의 인자로 직접 값을 넣어주고 엔터만 쳐도 입력값의 갯수가 int 타입 변수에 할당되는 것을 확인할 수 있음

### 약수 / 소수 구하기
n까지의 약수 혹은 소수를 구한다고 할 때 n의 제곱근까지만 체크해도 되는 이유
`약수`
- n = a * b라고 했을 때 a가 b보다 작다면 a는 n의 제곱근보다 클 수 없다. (a가 가장 커지는 시점은 b와 같을 때 즉, n의 제곱근과 같을 때이기 때문에) 
- 그렇기 때문에 a를 구하려고 한다면 1부터 a의 최대값이 될 수 있는 n의 제곱근까지만 체크해주면 되는 것이다.
`소수`
- 에라토스 테네스의 체 개념에 따라 제곱근까지만 체크해도 됨
- 혹은 직접 해보면 됨

### 큐(Queue)의 개념
- FIFO(First In First Out) 선입선출의 구조를 가짐
ex) 은행에서 먼저 번호표 뽑은 사람이 먼저 업무를 보는 것을 생각하면 됨

### Linked List 개념
![](Pasted%20image%2020230502184215.png)
- 이런 형태의 자료구조임
- 즉, 메모리 상에는 다 따로 떨어져 있지만 서로 다음 값에 대한 주소를 짝꿍처럼 가지고 있어 연결이 되는 형태라고 할 수 있음

##### Linked List가 Array List에 비해 좋은 점
- 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간에 수행할 수 있음
`ArrayList의 삽입 과정`
1. 삽입될 자료를 기준으로 뒤의 데이터를 전부 한칸씩 밀어냄
2. 해당 위치에 원하는 데이터를 입력
`ArrayList의 삭제 과정`
1. 삭제될 자료가 위치한 인덱스의 자료를 삭제함
2. 삭제된 자리 뒤에 있는 데이터들을 한칸씩 당김

`Linked List의 삽입 과정`
1. A와 B 사이에 데이터를 추가한다고 했을 때 추가될 자료의 node(주소값을 담는 칸) 생성
2. A의 node에 다음 주소값을 해당 자료의 주소값으로 바꾸고
3. B의 이전 node에 이전 주소값을 해당 자료의 주소값으로 바꿈

- ArrayList와는 다르게 자료를 무한대로 삽입할 수 있음(ArrayList는 한정되어 있음)

 단점으로는 검색할 때 ArrayList에 비해 느리다는 것

### 기본 for문 for-each문
기본 for문은 배열이나 컬렉션의 길이(length())를 구하고, 인덱스를 증가시키며 반복하는 과정이 필요함. 이 과정에서 불필요한 계산과 연산이 많이 발생할 수 있다고 함. 반면에 for each문은 컬렉션에 대한 이터레이터를 사용하여 각 요소에 접근하므로, 반복할 때마다 인덱스를 구하거나, 인덱스 변수를 업데이트 하는 과정이 필요하지 않기 때문에 더 빠른 것

### 순열/ 중복순열/ 조합/ 중복조합
- 조합
순서는 상관없이 누가누가 선택되었는가 만 생각하면 됨
- 순열
누가 선택되었는가 뿐 아니라 누가 몇번째로 선택되었는가(순서)도 생각해야 됨
- 중복순열
순서도 고려할 수 있지만 같은 놈이 여러 번 선택될 수도 있는 경우도 생각하는 것임
ex) 중복을 허락하고 세자리 함수를 만드는 경우의 수
- 중복조합
중복은 허락하되 누가 선택되었는지만 중요함
ex) 2개의 서로 다른 접시에 사과 3개를 집어넣는 경우

구현 방식 : 재귀 함수 이용

**JAVA for문  : 1초에 1억번씩 수행가능**
- for문 하나 : O(n) : n/1억한 정도만큼 시간이 걸림 -> 즉, 1억번까지는 1초가 안 걸림
- 이중 포문 : O(n2) : n에 2제곱한 것/1억한 만큼 시간이 걸림 -> n이 10만이라면 10만을 제곱하면 100억이 되고 1억으로 나눈 값은 100이 되니 100초나 걸린다는 것을 알 수 있음
- 1/2 * n 도 빅오 표기법으로 작성할 때는 그냥 O(n)이라고 적음

O(_g_(_n_)) = {_f_(_n_) | 모든 _n_ ≥ _n0_에 대하여 _f_(_n_) ≤ _c_ × _g_(_n_)인 양의 상수 _c_와 _n0_가 존재한다}
- `f(n) |`은 f(n)의 조건을 적는다는 의미이고 나머지는 그냥 아는대로
- 조건에 부합하는 애들을 묶어 집합으로 만든 놈을 O(g(n))이라고 써놓은 것