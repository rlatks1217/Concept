console.log에 찍힌 Array를 실제로 열어보는 시점에는 그 시점의 Array 상태를 보고 가져와서 console에 보여주게 된다. 즉, log 코드를 splice 같은 것으로 삭제하기 전에 실행했더라도 여는 것은 삭제되고 나서 열게 되므로 열어보는 시점엔 삭제된 이후의 상태를 가져와서 보여주게 되는 것이다.

## 문장 요약 알고리즘

PlaintextParser.from_string(text, Tokenizer("korean")) : 한국어 문장의 분리 기준으로 들어오는 text를 문장 단위로 나누고 그 나눠진 문장들을 가진 객체를 생성해주는 코드

tokenizer : 문장분리 기준을 적어주는 속성임 한국어 문장을 분리하기 위해 korean을 속성값으로 적는다.(english라고 적지 않는 이유는 영어 문장은 공백을 기준으로만 문장을 분리하면 되기 때문에 english라고 적어도 상관없지만 한국어 문장은 '마침표(.)', '물음표(?),'느낌표(!)', '따옴표(')', '괄호' 등의 기호를 사용하여 보다 정교하게 분리해야 하기 때문에 korean이라고 적는 것이 적절하다.)

summarizer = LsaSummarizer() : parser.doucument로 문장들을 받아서 그 문장들의 요약본을 생성하는 역할을 하는 객체
summary = summarizer(parser.document, 1) : 해당 객체를 통해서 1문장으로 요약해주고 요약본을 tuple형태로 반환해주는 코드 괄호 안에는(요약할 문장을 담은 객체, 몇개의 문장으로 요약할지)를 적어준다.


## 유사도 측정 알고리즘

### 벡터화
Term Frequency : 한 문서(문장) 내에서 단어가 등장한 횟수를 나타내는 지표임 즉, 해당 단어의 등장 빈도를 의미함 => 한 문서에서 등장 횟수가 많다면 중요한 역할을 한다고 판단함, 그런데 the, of와 같은 불용어는 등장 빈도수가 높다고는 해도 실제로 중요한 의미를 담고 있는 단어는 아니기 때문에 제거하고 계산해야 함(TfidfVectorizer를 사용할 땐 내부적으로 알아서 계산 전에 불용어를 제거하는 과정을 거침)

ex) 문서 A에서 단어 "apple"이 3번 등장했다면, "apple"의 TF 값은 3
Inverse Document Frequency (IDF): 전체문서에서 해당 단어가 등장한 문서의 갯수를 의미함 해당 단어가 많은 문서에서 등장한다는 것은 그만큼 흔하게 사용되는 단어이고 그것은 곧 그렇게 중요한 역할을 하는 단어가 아닌 흔한 단어일 뿐이라고 판단할 수 있음

##### 즉, Term Frequency는 높으면서 Inverse Document Frequency (IDF)는 낮은 단어가 중요한 역할을 하는(핵심을 가리킬 가능성이 높은) 단어라고 할 수 있음
##### 그래서 벡터화를 한 결과에서 각 수치가 의미하는 바는 결국 단어의 중요도임

### 벡터화 과정
1. 문장을 토큰화(문장을 여러 단어로 나누는 과정)한다. 이 과정에서 문장부호나 불용어 등은 제거한다.
2. 각 단어의 TF-IDF 값을 계산한다. 이 값은 해당 단어가 문장에서 얼마나 중요한지를 나타낸다
3. 문장마다 벡터화를 거쳐 결과를 각각 벡터 형태(1차원 list 형태)로 저장하게 된다.
4. 여러 문장을 벡터화하기 때문에 전체 list안에 벡터화가 된 결과들이 list형태로 들어가게 되는 것이다(즉, 결과가 2차원 list 형태가 됨)

### 유사도 측정 과정
1. 모든 문장에서 공통적으로 나타내는 단어를 불용어로 보고 제거 후 벡터화를 하기 위해서 모든 문장을 담은 list를 vectorizer 안에 넣는다.
2. 벡터화 후 그 list에서 두 문장의 유사도를 계산한 후 결과를 반환하게 된다. Matrox 형태로 반환하게 된다.
3. 유사도를 측정할 문장들만 벡터화시키는 것이 가장 정확하다.

### 유클리드 거리 유사도
유클리드 거리는 단어의 빈도수가 유사하지 않은 경우에 정확한 결과를 얻을 수 없음
ex) "I love cats and dogs"가 많이 등장하는 A문서와 "I love turtle"가 많이 등장하는 B문서가 있다고 했을 때 "I love"두 문서에 공통적으로 많이 등장한다는 점에서 두 문서가 서로 유사한 것으로 판단해야 함 => 하지만 유클리드 거리 유사도의 경우 거리를 기준으로 유사도를 측정하기 때문에 다르다고 판단할 가능성이 큼

또한 비교하려는 문장 간의 스케일(벡터의 크기(길이))이 많이 차이 나는 경우에는 정확한 측정이 어려울 수 있기 때문에 사용하는 것은 좋지 않음 => 반면, 코사인 유사도는 두 지점의 방향이 같으면 유사하다고 판단하기 때문에 스케일이 차이나더라도 상대적으로 정확한 유사도 측정이 가능함


### 두 문장이 관련없는 경우에도 유사도가 높은 이유
단어의 빈도수가 유사하게 분포하는 경우: 이 경우, 두 비교대상들이 의미상으로는 연관이 없을 수 있지만, 단어 사용 패턴이 유사하여 유사도가 높게 나타날 수 있습니다.
문장 자체가 길지 않기 때문에 핵심 단어라도 단어의 빈도수가 크지 않아 핵심 단어를 기준으로 유사도를 측정하기에 어려움

1. vs Code에 python 파일 만들기
2. 실행하려는 코드 작성
3. python 파일명.py로 서버 기동
4. pip install flask-restful 설치
5. CORS 해결을 위해 pip install flask-cors 설치 후 import


### TF - IDF
하나의 Document에서 DF는 1임(100개의 문서라면 DF = 100)
100개의 문서에서 특정 단어가 10개 나왔다면 IDF값은 10(100/10)임
모든 문서에서 자주 등장하는 단어의 중요도는 낮고 특정 문서에서 자주 등장하는 단어는 중요도가 높다고 판단

사용자가 검색을 했을 때 어떤 데이터가 먼저 보여질지 판단할 때 중요한 척도가 됨

1. 토큰화
2. 불용어 제거
3. 정규화(단어를 원형으로 만듬/정규화를 거치지 않으면 각기 다른 같은 의미의 단어들의 빈도수가 모두 개별적으로 counting될 것임)


### Spring 관련
- TypeAlias : 해당 Alias를 사용하는 Mapper가 없어도 오류가 
남
- 프로젝트에서 src/main/resources가 classpath임

##### @RequestBody @ModelAttribute 차이
- axios를 통해 서버로 요청을 보낼 때 데이터를 보내게 되면 쿼리스트링 형태가 form 형태가 아닌 이상 일반적으로 json형태로 데이터를 보내게 됨
- @ModelAttribute는 쿼리스트링 형태의 데이터나 form 객체 형태의 데이터를 받아 자바 인스턴스의 필드로 꽂아넣기 위해 사용하는 어노데이션임
=> 따라서 axios 요청을 보낼 때 form이 아닌 자바스크립트 객체 형태를 requestBody에 담아 보내게 되면 json 형태로 데이터가 서버로 전송되는데 @ModelAttribute는 json 데이터를 자바 객체로 변환하는 기능이 없기 때문에 @ModelAttribute가 생략되어 있는 vo 타입의 매개변수로는 데이터를 받을 수 없는 것임
- @RequestBody는 json이나 xml 형태의 데이터도 자바객체형태로 바꾸는 역할을 수행함. 그래서 그냥 자바스크립트 객체를 requestBody에 담아서 보내도 json 형태의 데이터를 자바객체로 바꿔서 vo매개변수에 넣어주는 것이 가능한 것임
- 또한 requestBody는 2개 이상의 매개변수 앞에는 붙을 수 없음


### Vue 관련
- vue 내에서 배열의 인덱스로 직접 접근하여 요소를 추가, 삭제, 수정하는 경우 반응성이 이뤄지지 않을 수 있음 => 그러므로 push()와 같은 함수를 쓰는 것이 적절함
- callback 함수에 .bind(this)를 작성해주지 않으면 "this.$store" 혹은 "this.$router"를 사용할 수 없음 => callback 함수는 원래 this라는 키워드가 없기 때문(JS 설계 오류!)
- vue 파일 import 시 @의 의미는 해당 파일을 최상위 폴더인 src부터 찾겠다는 의미

##### 상태관리패턴
- 앱의 규모가 커지면 props, emit를 사용해야 할 컴포넌트가 많아짐
- 하지만 어디서 데이터를 보내며 어디서 데이터를 받는지 표현하고 파악하는 것이 어려움
- 이러한 문제점을 해결하기 위해 모든 데이터 통신을 저장소처럼 한 곳에서 중앙 집중식으로 관리하는 것이 상태관리임

1. state
- 쉽게 말해서 프로젝트에서 사용할 변수를 정의하는 것
-  state는 mutations를 통해서만 가능함
- 함수 안에서 this.$store.getters.함수명으로 접근
- html 안에서는 $store.getters함수명으로 접근
- 물론 이렇게 getter역할을 하는(특정 변수를 return하는) 함수가 getters안에 정의가 되어 있어야 함
사용예시
![](Pasted%20image%2020230424200204.png)
2. Mutations
- Mutations의 주요 목적은 state(변수)를 변경시키는 것
- 비동기 처리가 아닌 동기 처리를 함
- commit('함수명','전달인자')으로 실행을 시킴
- mutations 내에 함수 형태로 작성함
사용예시(state.list와 같은 형태로 변수를 호출해서 안의 값을 바꿀 수 있음)
![](Pasted%20image%2020230424200138.png)
3. Actions
- Actions의 주요 목적 역시 state를 업데이트하기 위해 사용됨
- 동기 처리가 아닌 비동기 처리를 함. 순서에 상관없이 먼저 종료된 함수의 피드백을 받아 후속처리를 하게 됨
- dispatch('함수명', '전달인자')로 실행시킬 수 있음
ex) 예를 들어 API에 요청을 보내고 해당 요청의 결과를 state에 반영해야 하는 경우 이때, API 요청을 비동기로 하려고 한다면 mutations은 사용할 수 없음 따라서 actions를 사용하여 비동기 로직을 처리하고, 해당 결과를 mutations을 통해 state에 반영
정의
![](Pasted%20image%2020230424202005.png)
사용예시
![](Pasted%20image%2020230424202025.png)
4. getters
- state에서 데이터를 가져오는 방법을 정의하는 메소드임(흔히 아는 getter의 역할을 함)
사용예시
![](Pasted%20image%2020230424202315.png)

##### this.$store.state.변수명 = 1 과 state 속성을 통해 정의하는 것의 차이
- 일단 mutations를 통해서만 변수값을 바꾸는 것이 vueX의 원칙임(전자처럼 값을 변경할 경우 state는 mutations를 통해서만 변경이 가능하다는 원칙에 어긋나는 것임)
- 또한 전자와 같이 개별적으로 값을 할당하게 될 경우 어디서 바꿨는지를 모르기 때문에 나중에 유지보수할 때 문제가 생길 수 있음
- 그래서 원칙에 따라서 변경을 하는 것이 가장 바람직함

### 카카오 지도 API

기본
![](Pasted%20image%2020230425092249.png)

kakao.maps.LatLng(위도, 경도)로 넣어줘야 함
마커 여러 개
![](Pasted%20image%2020230425092155.png)

### axios
- data는 HTTP requestBody에 데이터를 담는 방식. 주로 POST, PUT, PATCH와 같은 요청 방식에서 사용됨
- params는 requestBody가 아닌 url에 쿼리스트링 형태로 데이터를 붙여서 보내는 방식. 주로 GET, DELETE와 같은 요청 방식에서 사용됨

### silder 사용
1. powershell 에서 npm install vue-tiny-slider 로 tiny-slider 설치
2. 
3.     components: {
        'tiny-slider' : VueTinySilder
    }
    작성
4.  https://hyeooona825.tistory.com/43 참고

### 프로젝트 내에서 background-image 설정하는 방법
- :style="`background-image: url(${imagePath})`" 해당 html에 작성(백틱 포함)
- data() 안에 imagePath라는 변수 있어야 함(당연히 이미지의 경로 할당되어 있어야 함)
- 이 때 이미지 파일은 무조건 public 안에 있어야 함(기본적으로 public 폴더 안에 있는 파일만 저 속성을 이용하여 띄울 수 있기 때문)
- root component에 설정하는 것은 좋지 않음 별도의 div를 만들어서 설정해야 그라데이션 같은 게 적용됨

### 그라데이션 설정법
![](Pasted%20image%2020230516112631.png)
- to bottom,과 같은 인자가 그라데이션의 방향 결정
- rgba(R값, G값, B값, 투명도(높을수록 투명해짐))
- rgba(255, 255, 255, 0) 를 많이 쓸수록 더 정교한 그라데이션이 가능하다.
- 위 아래로 그라데이션을 하는 경우 높이가 반드시 px로 명시되어 있어야 한다.
![](Pasted%20image%2020230516112958.png)
- 또한 다음과 같이 position설정을 해줘야 해당 배경이미지가 다른 컴포넌트들에 영향을 받지 않고 배경으로 위치할 수 있음
![](Pasted%20image%2020230516195052.png)
이렇게 해당 태그명으로 잡아야 CSS 잡힘  ㄷㄷ;