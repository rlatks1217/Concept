### BFS와 DFS의 기초 개념
- 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말함
- 대표적인 그래프 탐색 알고리즘이 BFS와 DFS임

`Stack`
- 가장 먼저 들어온 데이터가 가장 나중에 나가는 (FILO) 형식의 자료구조임
ex) 박스 쌓기, 프링글스 과자통

![](../../README_resources/Pasted%20image%2020230508102033.png)

![](../../README_resources/Pasted%20image%2020230508102527.png)

s.peek() : 스택의 최상단 자료를 반환만 하는 메소드(삭제는 아님)
s.pop() : 스택의 최상단 자료를 반환하고 stack에서 해당 자료를 삭제하는 메소드

`Queue`
- 가장 먼저 들어온 데이터가 먼저 나가는(FIFO) 형식의 자료구조
ex) 터널

![](../../README_resources/Pasted%20image%2020230508104026.png)

- 삭제 연산을 수행할 때는 5, 2, 3, 7 순서로 삭제가 이뤄지게 됨

![](../../README_resources/Pasted%20image%2020230508104246.png)

q.offer(숫자) : 자료구조에 데이터 집어넣기
q.poll() : 데이터 하나씩 꺼내기

`재귀함수` : Recursive Function
- 자기 함수를 다시 호출하는 함수를 의미
- 제한 없이 계속 출력하게 될 경우 StackOverflowError가 발생하게 됨
- stack 자료구조처럼 처음 실행했던 함수가 가장 마지막에 종료됨
- 모든 재귀함수는 반복문을 이용하여 동일한 기능을 구현할 수 있음
- stack을 이용해야 할 경우 stack 대신 재귀함수를 이용하는 경우가 많음(즉, 자바 내부의 메소드들이 쌓이는 stack을 이용하는 것임)

`유클리드호제법`
- 호제법 : 두 수가 서로 상대방 수를 나누어 결국 원하는 수를 얻는 알고리즘을 일컫는 말
- 2개의 자연수 a, b(a>b)에 대하여 a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대 공약수와 같음
- b와 r의 최대공약수 또한 위의 방법에 따라 b를 r로 나눈 나머지와 r과 해당 나머지의 최대공약수와 같음을 통해 구할 수 있음 => 계속 이러한 과정을 반복하게 되면 비교적 작은 수들을 통해서 최대공약수를 구할 수 있음을 알 수 있음
- 같은 연산과정이 반복되므로 재귀함수를 통해 구할 수 있음
- GCD : 최대공약수를 의미함

### DFS : 깊이 우선 탐색
- 그래프(노드와 간선으로 이뤄진 자료구조)에서 깊은 부분을 우선으로 탐색하는 알고리즘
- 노드 : 그래프의 한 지점
- 간선 : 노드 간의 연결선

- DFS는 스택 자료구조(혹은 재귀함수)를 이용하며, 구체적인 동작 과정은 다음과 같음
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 함
2. 스택의 최상단 노드(가장 마지막에 들어간 놈)에 방문하지 않는 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리/ 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복함

- 여러 인접노드가 있을 경우 인접노드 중 어떤 노드를 먼저 방문할 지 기준이 있어야 되는 경우와 그렇지 않은 경우가 있음(대부분 전자의 경우가 많음)

![](../../README_resources/Pasted%20image%2020230508121426.png)

위 예시는 기준이 번호가 낮은 인접노드부터일 경우로 가정함 

- 다음과 같이 1, 7, 2, 6순으로 방문하게 됨(가장 깊은 곳까지)
- 방문하지 않은 노드가 더이상 없을 경우 최상단에 있는 노드(6)을 꺼내고 다시 방문과정을 진행함=> 다음 순서는 당연히 8임 
  => 8까지 방문한 후에는 더이상 깊이 내려가서 방문할 노드가 없으므로 8을 꺼내게 됨 
  => 7에서도 더이상 방문할 노드가 없으므로 꺼냄
  => 2에서도 더이상 방문할 노드가 없으므로 꺼냄 
  => 마지막 1로 돌아와서 방문하지 않은 3을 스택에 넣으면서 다시 다른 방향으로 방문을 시작함 => 이런 식으로 전체 그래프에서 더이상 방문하지 않은 노드가 없을 때까지 반복

![](../../README_resources/Pasted%20image%2020230508123145.png)
  
index 0은 사용하지 않기 위해서 노드의 갯수보다 하나 많은 길이로 방문여부를 체크할 배열 생성

### BFS : 너비 우선 탐색
- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- Queue 자료구조를 이용하고 구체적인 동작 과정은 다음과 같음
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 함
2. !큐에서 인접노드를 처리할 노드를 꺼낸 뒤에! 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 함
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복함

![](../../README_resources/Pasted%20image%2020230508161839.png)

- 위와 같이 3을 먼저 꺼내고 3의 인접노드 중 방문하지 않는 노드들을 큐에 집어넣고(인접노드라도 할지라도 이미 방문한 노드는 집어넣는 것이 아님) 방문처리를 함
- 인접노드들이 방문을 모두 한 경우 해당 노드를 꺼내기만 하면 됨
### 그리디 알고리즘

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미함
- 항상 최적의 해를 보장할 수 없을 때가 많음 그러나 코딩 테스트의 경우 그리디 알고리즘을 사용하였을 때 최적의 해가 보장되는 것 문제로 출제하는 경향이 있음