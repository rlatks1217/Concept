

**JAVA for문  : 1초에 1억번씩 수행가능**
- for문 하나 : O(n) : n/1억한 정도만큼 시간이 걸림 -> 즉, 1억번까지는 1초가 안 걸림
- 이중 포문 : O(n2) : n에 2제곱한 것/1억한 만큼 시간이 걸림 -> n이 10만이라면 10만을 제곱하면 100억이 되고 1억으로 나눈 값은 100이 되니 100초나 걸린다는 것을 알 수 있음
- 1/2 * n 도 빅오 표기법으로 작성할 때는 그냥 O(n)이라고 적음

O(_g_(_n_)) = {_f_(_n_) | 모든 _n_ ≥ _n0_에 대하여 _f_(_n_) ≤ _c_ × _g_(_n_)인 양의 상수 _c_와 _n0_가 존재한다}
- `f(n) |`은 f(n)의 조건을 적는다는 의미이고 나머지는 그냥 아는대로
- 조건에 부합하는 애들을 묶어 집합으로 만든 놈을 O(g(n))이라고 써놓은 것
### 약수 / 소수 구하기
n까지의 약수 혹은 소수를 구한다고 할 때 n의 제곱근까지만 체크해도 되는 이유
- n = a * b라고 했을 때 a가 b보다 작다면 a는 n의 제곱근보다 클 수 없다. (a가 가장 커지는 시점은 b와 같을 때 즉, n의 제곱근과 같을 때이기 때문에) 
- 그렇기 때문에 a를 구하려고 한다면 1부터 a의 최대값이 될 수 있는 n의 제곱근까지만 체그해주면 되는 것이다.

### 큐(Queue)의 개념
- FIFO(First In First Out) 선입선출의 구조를 가짐
ex) 은행에서 먼저 번호표 뽑은 사람이 먼저 업무를 보는 것을 생각하면 됨

### Linked List 개념
![](../../README_resources/Pasted%20image%2020230502184215.png)
- 이런 형태의 자료구조임
- 즉, 메모리 상에는 다 따로 떨어져 있지만 서로 다음 값에 대한 주소를 짝꿍처럼 가지고 있어 연결이 되는 형태라고 할 수 있음

##### Linked List가 Array List에 비해 좋은 점
- 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간에 수행할 수 있음
`ArrayList의 삽입 과정`
1. 삽입될 자료를 기준으로 뒤의 데이터를 전부 한칸씩 밀어냄
2. 해당 위치에 원하는 데이터를 입력
`ArrayList의 삭제 과정`
1. 삭제될 자료가 위치한 인덱스의 자료를 삭제함
2. 삭제된 자리 뒤에 있는 데이터들을 한칸씩 당김

`Linked List의 삽입 과정`
1. A와 B 사이에 데이터를 추가한다고 했을 때 추가될 자료의 node(주소값을 담는 칸) 생성
2. A의 node에 다음 주소값을 해당 자료의 주소값으로 바꾸고
3. B의 이전 node에 이전 주소값을 해당 자료의 주소값으로 바꿈

- ArrayList와는 다르게 자료를 무한대로 삽입할 수 있음(ArrayList는 한정되어 있음)

 단점으로는 검색할 때 ArrayList에 비해 느리다는 것

### 기본 for문 for-each문
기본 for문은 배열이나 컬렉션의 길이(length())를 구하고, 인덱스를 증가시키며 반복하는 과정이 필요함. 이 과정에서 불필요한 계산과 연산이 많이 발생할 수 있다고 함. 반면에 for each문은 컬렉션에 대한 이터레이터를 사용하여 각 요소에 접근하므로, 반복할 때마다 인덱스를 구하거나, 인덱스 변수를 업데이트 하는 과정이 필요하지 않기 때문에 더 빠른 것

### BFS와 DFS의 기초 개념
- 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말함
- 대표적인 그래프 탐색 알고리즘이 BFS와 DFS임

`Stack`
- 가장 먼저 들어온 데이터가 가장 나중에 나가는 (FILO) 형식의 자료구조임
ex) 박스 쌓기, 프링글스 과자통
![](../../README_resources/Pasted%20image%2020230508102033.png)
![](../../README_resources/Pasted%20image%2020230508102527.png)
s.peek() : 스택의 최상단 자료를 반환만 하는 메소드(삭제는 아님)
s.pop() : 스택의 최상단 자료를 반환하고 stack에서 해당 자료를 삭제하는 메소드

`Queue`
- 가장 먼저 들어온 데이터가 먼저 나가는(FIFO) 형식의 자료구조
ex) 터널
![](../../README_resources/Pasted%20image%2020230508104026.png)
- 삭제 연산을 수행할 때는 5, 2, 3, 7 순서로 삭제가 이뤄지게 됨
![](../../README_resources/Pasted%20image%2020230508104246.png)
q.offer(숫자) : 자료구조에 데이터 집어넣기
q.poll() : 데이터 하나씩 꺼내기

`재귀함수` : Recursive Function
- 자기 함수를 다시 호출하는 함수를 의미
- 제한 없이 계속 출력하게 될 경우 StackOverflowError가 발생하게 됨
- stack 자료구조처럼 처음 실행했던 함수가 가장 마지막에 종료됨
- 모든 재귀함수는 반복문을 이용하여 동일한 기능을 구현할 수 있음
- stack을 이용해야 할 경우 stack 대신 재귀함수를 이용하는 경우가 많음(즉, 자바 내부의 메소드들이 쌓이는 stack을 이용하는 것임)

`유클리드호제법`
- 호제법 : 두 수가 서로 상대방 수를 나누어 결국 원하는 수를 얻는 알고리즘을 일컫는 말
- 2개의 자연수 a, b(a>b)에 대하여 a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대 공약수와 같음
- b와 r의 최대공약수 또한 위의 방법에 따라 b를 r로 나눈 나머지와 r과 해당 나머지의 최대공약수와 같음을 통해 구할 수 있음 => 계속 이러한 과정을 반복하게 되면 비교적 작은 수들을 통해서 최대공약수를 구할 수 있음을 알 수 있음
- 같은 연산과정이 반복되므로 재귀함수를 통해 구할 수 있음
- GCD : 최대공약수를 의미함

### DFS : 깊이 우선 탐색
- 그래프(노드와 간선으로 이뤄진 자료구조)에서 깊은 부분을 우선으로 탐색하는 알고리즘
- 노드 : 그래프의 한 지점
- 간선 : 노드 간의 연결선

- DFS는 스택 자료구조(혹은 재귀함수)를 이용하며, 구체적인 동작 과정은 다음과 같음
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 함
2. 스택의 최상단 노드(가장 마지막에 들어간 놈)에 방문하지 않는 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리/ 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복함

- 여러 인접노드가 있을 경우 인접노드 중 어떤 노드를 먼저 방문할 지 기준이 있어야 되는 경우와 그렇지 않은 경우가 있음(대부분 전자의 경우가 많음)

![](../../README_resources/Pasted%20image%2020230508121426.png)
위 예시는 기준이 번호가 낮은 인접노드부터일 경우로 가정함 

- 다음과 같이 1, 7, 2, 6순으로 방문하게 됨(가장 깊은 곳까지)
- 방문하지 않은 노드가 더이상 없을 경우 최상단에 있는 노드(6)을 꺼내고 다시 방문과정을 진행함=> 다음 순서는 당연히 8임 
  => 8까지 방문한 후에는 더이상 깊이 내려가서 방문할 노드가 없으므로 8을 꺼내게 됨 
  => 7에서도 더이상 방문할 노드가 없으므로 꺼냄
  => 2에서도 더이상 방문할 노드가 없으므로 꺼냄 
  => 마지막 1로 돌아와서 방문하지 않은 3을 스택에 넣으면서 다시 다른 방향으로 방문을 시작함 => 이런 식으로 전체 그래프에서 더이상 방문하지 않은 노드가 없을 때까지 반복

![](../../README_resources/Pasted%20image%2020230508123145.png)
  index 0은 사용하지 않기 위해서 노드의 갯수보다 하나 많은 길이로 방문여부를 체크할 배열 생성

### BFS : 너비 우선 탐색
- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- Queue 자료구조를 이용하고 구체적인 동작 과정은 다음과 같음
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 함
2. !큐에서 인접노드를 처리할 노드를 꺼낸 뒤에! 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 함
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복함
![](../../README_resources/Pasted%20image%2020230508161839.png)
- 위와 같이 3을 먼저 꺼내고 3의 인접노드 중 방문하지 않는 노드들을 큐에 집어넣고(인접노드라도 할지라도 이미 방문한 노드는 집어넣는 것이 아님) 방문처리를 함
- 인접노드들이 방문을 모두 한 경우 해당 노드를 꺼내기만 하면 됨
### 그리디 알고리즘

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미함
- 항상 최적의 해를 보장할 수 없을 때가 많음 그러나 코딩 테스트의 경우 그리디 알고리즘을 사용하였을 때 최적의 해가 보장되는 것 문제로 출제하는 경향이 있음
### 정규식
- 문자열 데이터 중에서 원하는 패턴과 일치하는 문자열 부분을 찾아내기 위해 사용되는 것으로 미리 정의된 기호와 문자를 이용해서 작성한 문자열을 말한다.
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%95%EA%B7%9C%EC%8B%9DRegular-Expression-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%A0%95%EB%A6%AC

### 행렬곱
- 행렬 곱셈의 조건 : 행렬 A와 B를 곱할 때 A의 열의 개수와 B의 행의 개수가 같아야 함
- 결과 행렬은 (A의 행 x B의 열)이 됨
### N^2배열자르기
- 해당 2차원 배열을 직접 만들어서 해결하면 메모리초과가 날 것임
- 1차원 배열에서만 처리를 해야 하는데 그러면 어떻게 해야 하는가?
1. 각 인덱스(i)마다 /n을 해주면 해당 값이 몇 번째 행인지가 나옴
2. 각 인덱스(i)마다 %n를 해주면 해당 값이 몇 번째 열인지가 나옴
3. 문제에 대입해 보면 (left+1)/n과 (left+1)/n를 구해준다(왜? 실제로 2차원의 각 행을 일렬(1차원 배열)로 쭉 늘어뜨렸을 때 찾으려는 값(자르기 시작할 인덱스의 값)이 left+1이기 때문이다. / 인덱스는 0부터 시작이지만 n은 1부터 시작이므로 1을 더해준 값이 실제 값일 것이다.)

그런데 실제로 2차원 배열안의 각 값들이 어떤 식으로 채워지는지를 상상해보면
![](../../README_resources/Pasted%20image%2020230524151401.png)
- 이렇게 오른쪽 끝과 아랫쪽 끝은 모두 같은 숫자를 이루는 형태로 채워질 것(즉, 오른쪽 끝과 아랫쪽 끝에 속하는 숫자는 모두 같은 숫자일 것임) => 몇번째 행이냐 or 몇번째 열이냐 가 곧 해당 값일 것임(+행, 열 = 해당 값임을 이용)

- 2차원 배열의 각 값들의 위치를 봤을 때  해당 자르기 시작하는 인덱스의 값에 대한 행과 열 중 더 바깥쪽 즉, 더 큰 쪽의 속하는 숫자가 해당 값임을 알 수 있음 => 그래서 더 큰 값이 곧 찾으려는 값이 되는 것

- MYSQL에서 HAVING절은 예외로 더 늦게 실행되는 SELECT절의 Alias를 사용할 수 있음 쿼리 최적화 과정(SELECT가 실행되기 이전 시점)에서 Alias만 먼저 생성되기 때문임

- 컬렉션 객체에는 엘리먼트가 추가되거나 제거될 때 발생함! for-each의 경우 실행 시 내부적으로 Iterator 객체가 생성되는데 이 객체가 생성 시 컬렉션의 상태를 기억함 => 그래서 생성 시의 컬렉션 구조와 달라지면 그 다음 반복 작업에서 ConcurrentModificationException이 발생하게 될 것임

- 요소를 추가할 때마다 자동으로 1씩 증가하는 ArrayList의 인덱스를 지칭하는 변수가 modCount임