- 명령어가 어떻게 생겨야 명령어 파이프라이닝에 유리한가?

### 명령어 집합(ISA라고 함)
- CPU가 실행하는 명령어의 세세한 생김새, 연산 방식, 주소 지정 방식 등은 CPU마다 다름
- 명령어 집합 : CPU가 이해할 수 있는 명령어들의 모음
-> 아래 사진처럼 CPU가 어떤 명령어 집합을 이해할 수 있는지에 따라 실행하려는 명령어의 의미가 달라질 수 있음
- 명령어 집합이 달라지면 명령어 해석 방식, 레지스터의 종류와 개수, 파이프라이닝의 용이성 등 많은 것들이 달라지게 된다고 함(사람도 사용하는 언어가 다르면 생활습관이나 문화가 다른 것처럼)
- 결국 명령어 집합은 CPU가 사용하는 언어라고 할 수도 있음(CPU의 종류에 따라 이해할 수 있는 명령어 집합이 다르니까)

![](../../README_resources/Pasted%20image%2020240229053710.png)

- x86-64라는 명령어 집합만 이해할 수 있는 CPU는 ARM이라는 명령어 집합에 속한 명령어들의 의미를 이해할 수 없음
ex) 
x86-64의 push명령어 :  `A+B를 수행하라`
ARM의 push명령어 : `A-B를 수행하라`
여기서 CPU가 x86-64에 속한 명령어만 이해할 수 있다고 하면, push 명령어를 인식했을 때 무조건 `A+B를 수행하라`라는 의미로만 이해함

##### ISA의 의미
- CPU의 언어(명령어 집합은 CPU가 사용하는 언어라고 했으니까)
- 하드웨어가 어떻게 소프트웨어를 이해할지에 대한 약속

### CISC(Complex Instruction Set Computer)
- 의미 : 복잡한 명령어 집합을 활용하는 CPU
- 가변 길이 명령어 집합(다양한 형태와 크기의 명령어들을 가지고 있는 명령어 집합)을 활용함
- 명령어 하나하나가 복잡하고 다양한 기능을 제공하기 때문에 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있음

##### 단점
- 명령어 파이프라이닝이 불리함 -> 명령어마다 실행하는 데에 필요한 클럭 주기가 제각각이기 때문
- 명령어가 워낙 복잡하고 다양한 기능을 제공하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
- 명령어가 복잡하기 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기가 필요함
- 대다수의 명령어들은 사용 빈도가 낮음

### RISC
- 종류가 적고, 길이도 짧으며 1클럭 주기로 실행되는 규격화된 명령어들을 사용하는 CPU
- 메모리 접근을 최소화하는 경향이 있음(명령어도 load, store 두 가지임)
- 레지스터를 십분 활용
- 명령어의 종류가 CISC보다 적기 때문에 더 많은 명령어로 프로그램을 동작시킴
-> ex) CISC에는 더하기 명령어, 곱하기 명령어 외에 더하기, 곱하기를 둘 다 한번에 할 수 있는 명령어도 있지만 RISC에는 그러한 명령어가 없다고 하면, RISC에서는 더하기 명령어, 곱하기 명령어 이렇게 총 2번 실행해줘야 함

![](../../README_resources/Pasted%20image%2020240229060341.png)