- 운영체제는 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고, 프로세스들에게 적절한 수의 프레임을 할당해야 함
### 요구 페이징
- 처음부터 모든 페이지를 적재하지 않고 **요구되는 페이지만** 적재하는 것을 말함
**요구 페이징이 실행되는 양상**
1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근함
3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생함
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리에 적재하고 유효 비트를 1로 바꿈
5. 다시 1번 과정부터 실행함

※ **순수 요구 페이징** : 아무런 페이지도 요구하지 않은 채 무작정 실행부터 하는 것을 말함
이 경우에는 첫 번째 페이지를 실행할 때부터 페이지 폴트가 계속 발생하다가 실행을 시작하고 일정 시점이 지난 이후부터는 페이지 폴트가 일어나지 않는 양상을 보일 것

### 페이지 교체 알고리즘
- 요구 페이징 기법으로 페이지들을 추가적으로 적재하다 보면 언젠가는 메모리가 가득 차게 될 것임 
-> 메모리가 가득차고 나서 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지 중 어떤 페이지를 보조기억장치로 내보내야 할까? 를 결정하는 방법이 **페이지 교체 알고리즘**
####  좋은 페이지 교체 알고리즘이란?
- 페이지 폴트가 적은 알고리즘(페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하) -> 페이지 폴트가 자주 발생한다는 것은 보조기억장치로 내보내야 할 페이지를 잘못 고르고 있음을 의미함
- 페이지 폴트가 자주 발생하는지 알기 위해서는 페이지 폴트의 횟수를 알아야 함 
-> 이를 알기 위해 사용되는 것이 페이지 참조열(page reference string)
- **페이지 참조열** : CPU가 참조할 페이지들 중 연속된 페이지를 생략한 페이지열
(요구 페이징 기법을 사용할 경우 특정 페이지에 처음 참조하게 되는 시점에선 메모리에 해당 페이지가 없기 때문에 페이지 폴트가 발생할 것임 -> 즉, 페이지 참조열에 있는 페이지들은 무조건 페이지 폴트가 발생했던 페이지들이라고 할 수 있음)

```
2 2 2 3 5 5 5 3 3 7
```
CPU가 참조한 페이지가 다음과 같다면 페이지 참조열은 아래와 같음
```
2 3 5 3 7
```
연속된 페이지를 생략하는 이유는 만일 2페이지를 처음 참조했을 때 2페이지가 메모리에 없어서 페이지 폴트가 발생했다면 그 다음에 2페이지를 참조할 땐 페이지 폴트가 처리된 후일 것이고, 그렇다면 페이지 폴트가 발생하지 않을 것이므로 생략해도 무방한 것임

## 페이지 교체 알고리즘
### FIFO 페이지 교체 알고리즘
- 가장 오래 적재되어 있던 페이지를 보조기억장치로 내보내는 페이지 교체 알고리즘
- 아래 예시(그림)에서는 페이지가 처음 적재될 때 발생하는 페이지 폴트는 고려하지 않음

![](../../README_resources/Pasted%20image%2020240503063624.png)

- 프로그램 실행 내내 실행될 페이지에 경우 내보내선 안 되지만 위 알고리즘에서는 내보내기 때문에 그렇게 좋은 알고리즘은 아님
- FIFO 페이지 교체 알고리즘 - 보완책
	- **2차 기회(second-chance) 페이지 교체 알고리즘**
	- 참조 비트 1 : CPU가 한 번 참조한 적 있는 페이지
	- 참보 비트 0 : CPU가 참조한 적이 없는 페이지
	- 참조 비트가 1이라면 적재된 시점은 현재로 설정(가장 최근에 적재되었다고 간주)하고 맨 뒤에 있던 해당 페이지를 맨 앞으로 다시 보냄(한 번 더 기회를 주는 것임)
	- 참조 비트가 0이라면 가장 오래되었지만 참조된 적이 없는 페이지이므로 보조기억장치로 내보냄

### 최적 페이지 교체 알고리즘
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 페이지 교체 알고리즘
- 위의 예시(그림)와 마찬가지로 페이지가 처음 적재될 때 발생하는 페이지 폴트는 고려하지 않음

![](../../README_resources/Pasted%20image%2020240503065658.png)

- 가장 낮은 페이지 폴트율을 보장하는 페이지 겨체 알고리즘
- But 사용되지 않을 페이지를 예측하기는 어렵기 때문에 구현이 어려움
#### 보안책 - LRU(Least-Recently-Used) 페이지 교체 알고리즘
- 최적 페이지 교체 알고리즘과는 다르게 가장 오래 사용되지 않는 페이지를 교체하는 알고리즘
- `최근에 사용되지 않는 페이지는 앞으로도 사용하지 않지 않나?` 라는 생각에서 출발

![](../../README_resources/Pasted%20image%2020240507073718.png)

**페이지 폴트가 자주 발생하는 또다른 이유 : 프로세스가 사용할 수 있는 프레임 자체가 적어서임(이게 더 근본적인 이유임)**

### 스레싱과 프레임 할당
- 스레싱 : 프로세스가 **실행되는 시간보다 페이징에 더 많은 시간을 소요**하여 CPU이용률이 저해하는 문제를 말함

![](../../README_resources/Pasted%20image%2020240507074048.png)



