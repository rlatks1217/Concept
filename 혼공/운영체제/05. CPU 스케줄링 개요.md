### CPU 스케줄링
- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것
- 프로세스마다 우선순위가 다르기 때문에 그에 따라 스케줄링하는 것이 적절함
Ex) 입출력 작업이 많은 프로세스(ex - 비디오 재생)는 CPU 작업이 많은 프로세스보다 우선순위가 높음 왜? 입출력 작업이 이뤄지는 동안은 해당 프로세스는 대기 상태일 것이기 때문에 입출력 작업이 많은 프로세스가 우선적으로 CPU를 쓰게 하고, 대기하는 시간 동안 CPU작업이 많은 프로세스가 CPU를 사용하게끔 하는 것이 효율적이기 때문임

![](../../README_resources/Pasted%20image%2020240326213455.png)

- 우선순위에 대한 정보(스케줄링 정보)는 각 프로세스의 PCB에 저장됨
- 우선순위를 사용자가 임의로 정해줄 수 있음

### 스케줄링 큐
- 모든 프로세스의 PCB를 돌아다니면서 프로세스들이 어떤 작업을 하는지 판단하여 우선순위를 결정하는 것은 너무 비효율적임(그림 1 참고) -> 스케줄링 큐를 사용함(각 프로세스들이 원하는 작업 종류에 따라 줄 세우는 느낌 - 그림 2 참고)
 
 그림1
![](../../README_resources/Pasted%20image%2020240326213524.png)

그림2
![](../../README_resources/Pasted%20image%2020240326213558.png)

- 스케줄링 큐의 경우 반드시 선입선출일 필요는 없음 -> 덱처럼 앞 뒤로 집어넣고 내보낼 수 있다고 할 수 있음
#### 스케줄링 큐 종류
- 준비 큐 : 준비상태에 접어든 프로세스들(CPU를 사용하고자 하는 프로세스들)이 서는 줄임
- 대기 큐 : 입출력 창치를 이용하려는 프로세스들이 서는 줄임
- 실제로 해당 큐들에 삽입되는 건 PCB임

물론 먼저 큐에 삽입되었다고 해서 실제로 먼저 실행되는 것은 아님(우선순위에 따라 실행됨)

![](../../README_resources/Pasted%20image%2020240326213625.png)

#### 대기 큐
- 같은 장치를 요구한 프로세스들은 같은 큐에서 대기를 하게 됨
- 입출력 장치를 다 사용한 프로세스의 PCB는 당연히 다시 준비 큐로 삽입될 것임(정확히는 운영체제가 해당 프로세스의 PCB 상태를 `대기`에서 `준비`로 바꾼 후 준비 큐에 삽입하는 것임)

![](../../README_resources/Pasted%20image%2020240326213654.png)

- 만일 이미 CPU를 사용중인 프로세스가 있는데 다른 프로세스에서 급하게 처리해야 될 작업이 생긴다면?
### 선점형 스케줄링(preemptive scheduling)
- 현재 CPU를 사용 중인 프로세스(=실행중인 프로세스)로부터 CPU 자원을 빼앗아 다른 프로세스에 할당하는 방식(즉, CPU를 사용 중이었던 프로세스의 작업이 끝나지 않았음에도 불구하고 넘겨줄 수 있는 것임)
- 사실 위에서 그 동안 언급했던 스케줄링은 선점형 스케줄링을 말하는 것임(프로세스가 작업이 끝나지도 않았는데 점유할 수 있는 정해진 시간이 지나면 CPU를 뺏어서 다른 프로세스가 사용하도록 하는 방식이기 때문)
- 장점 : 어느 한 프로세스의 자원 독점을 막고 프로세스들이 골고루 자원을 사용할 수 있음
- 단점 : 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있음

![](../../README_resources/Pasted%20image%2020240326214557.png)

- 비선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스(=실행중인 프로세스)의 작업을 끝날 때까지 무조건 기다리게 하는 방식
- 현재 자원을 점유하고 있는 프로세스가 대기 상태가 되거나 종료되지 않는 이상, 다른 프로세스들은 해당 자원을 사용할 수 없음
- 장점 : 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적음
- 단점 : 모든 프로세스가 골고루 자원을 사용할 수 없음

