### 쓰기식 복사
- 이론적인 fork()
	- 프로세스 간에는 기본적으로 자원을 공유하지 않음 -> 자식 프로세스 생성 시 부모 프로세스의 내용을 통째로 복제하여 메모리에 적재
	- 자식 프로세스의 생성 시 시간이 지연되며 똑같은 내용의 프로세스가 두 개 메모리에 올라가는 것이므로 메모리 낭비임
- **쓰기 시 복사** : 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킴 (쓰기 작업이 없다면 이 상태 유지)
  즉, 메모리에 새로 자식 프로세스에 대한 프레임이 할당되는 것이 아님
- 그림에서 물리 주소 공간인 메모리에 페이지가 올라가 있는 것처럼 보이지만 실제로는 프레임이 적재되어 있는 것임

![](../../README_resources/스크린샷%202024-05-08%20073808.png)

이때, 부모 프로세스와 자식 프로세스 중 하나가 쓰기 작업을 하게 되면 새로운 프레임(쓰기 작업이 반영된 프레임)이 별도의 공간에 할당됨

### 계층적 페이징
- 프로세스 테이블의 크기는 생각보다 작지 않음 (프로세스의 크기 ↑ => 페이지 테이블의 크기 ↑) 즉, 메모리 상에서 차지하는 비중이 생각보다는 크다는 얘기임
- 그래서 프로세스를 이루는 모든 페이지 엔트리를 메모리에 넣어두는 것은 낭비
- 그러므로 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않는 방법이 필요함 -> 그 방법이 계층적 페이징
- **계층적 페이징** : 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식

![](../../README_resources/Pasted%20image%2020240509074016.png)

- 그림과 같이 하나의 페이지 테이블을 여러 개로 쪼개고 쪼개진 각 조각들을 또다른 페이지 테이블(Outer 페이지 테이블)에서 가리킴(각 조각들은 Outer 페이지 테이블의 각 페이지들과 링크됨)
- CPU와 가장 가까이 위치한 테이블(outer 페이지 테이블)은 항상 메모리에 유지
- outer 페이지 테이블을 통해 현재 접근하고자 하는 페이지 테이블 조각을 제외한 나머지는 보조기억장치에 있게 됨(필요할 때마다 스왑하게 될 것) 

계층적 페이징을 이용하는 환경에서 논리 주소의 내부 구조 

0755 

안쪽 페이지 위치에서 변위를 더하여 실제 접근하고자 하는 주소에 도달함 

0835(글자 부분까지) 

너무 여러 계층일 경우에는 페이지 폴트가 발생했을 때 테이블을 계속 타고타고 들어가야 하기 때문에 오히려 성능이 저하됨

