- 운영체제마다 다른 스케줄링 알고리즘을 적용하고 있으며, 너무나도 다양한 스케줄링 알고리즘이 존재함
- 각 알고리즘의 작동 방식과 장단점 위주로 학습

### 선입 선처리 스케줄링
- FCFS (First Come First Served) 스케줄링
- 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점형 스케줄링
- 단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용이 있음(=호위 효과)
- 호위 효과 : 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것

![](../../README_resources/Pasted%20image%2020240330161102.png)

### 최단 작업 우선 스케줄링
- 호위 효과를 방지하려면(=대기하는 시간을 줄이려면)? CPU 사용시간이 짧은 프로세스부터 실행시키면 대기 시간은 줄어들게 됨
	= SJF (Shortest Job First) 스케줄 
- 선점형 스케줄링으로 구현할 수도 있지만 기본적으로는 비선점형으로 분류되는 스케줄링
### 라운드 로빈 스케줄링
- RR(Round Robin - `돌아가면서 ~를 한다 라는 의미를 가지고 있음`) 스케줄링
- 선입 선처리 스케줄링 + 타임 슬라이스(time slice)
- 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
	- 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용
	- 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입(해당 프로세스 다음 순번의 프로세스와 문맥교환이 일어남)
- 타임 슬라이스의 크기가 중요함 
왜? 타임슬라이스의 크기가 너무 커지면 선입 선처리 방식으로 실행되는 거나 마찬가진이기 때문, 반면에 너무 작을 경우에는 프로세스 간 문맥교환이 너무 자주 일어나기 때문에 CPU에 부담이 너무 커기 때문

![](../../README_resources/Pasted%20image%2020240330161149.png)

### 최선 잔여 시간 우선 스케줄링
- SRT(Shortest Remaining Time) 스케줄링
- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
- 최단 작업 우선 스케줄링 : 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘
- 라운드 로빈 스케줄링 : 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
- 즉, 정해진 시간만큼 CPU를 사용하되, 다음의 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 짧은 프로세스가 선택될 것임
### 우선 순위 스케줄링
- 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행
- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링됨
- 최단 작업 우선순위 스케줄링과 최소 잔여 시간 스케줄링은 우선순위 스케줄링에 포함된다고 할 수 있음(작업 시간 or 남은 작업 시간에 따라 우선순위가 부여되는 것이나 마찬가지이기 때문)
- 문제점 : 기아(starvation) 현상
	- 우선순위가 높은 프로세스만을 실행하다 보면, 우선순위가 낮은 프로세스는 하염없이 대기만 하는 상황이 발생하게 됨 여기서 알 수 있듯이, 기아 현상이란 굶어서 죽는 것처럼 우선순위가 낮은 프로세스는 계속 실행되지 못하는 현상을 의미함

![](../../README_resources/Pasted%20image%2020240330161231.png)

##### -> 이를 방지하기 위한 기법 : 에이징(aging)
- 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
- 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법
	- 우선순위가 낮아도 언젠가는 우선순위가 높아지게 됨

### 다단계 큐 스케줄링
- MultiLevel queue 스케줄링
- 우선순위 스케줄링의 발전된 형태
- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리함
- 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스를 처리함
- 작업의 종류에 따라 프로세스들을 다른 큐에 담기도록 할 수 있으며, 큐에 따라 타임슬라이스의 크기, 스케줄링 방식 등을 다르게 적용할 수 있다는 장점이 있음

![](../../README_resources/Pasted%20image%2020240330161309.png)

- 기본적으로 프로세스는 큐 간의 이동은 불가능함 -> 기아 현상이 생길 수 있음 -> 다단계 피드백 큐 스케줄링의 등장
### 다단계 피드백 큐 스케줄링
- MultiLevel feedback queue 스케줄링
- 다단계 큐 스케줄링의 발전된 형태
- 큐 간의 이동이 가능함
- 에이징 기법도 적용이 가능함
- CPU 스케줄링의 가장 일반적인 형태임

**큐 이동 과정**
-> CPU 이용이 많이 필요한 프로세스(=CPU 집중 프로세스)일 경우, 타임 슬라이스가 끝났음에도 작업이 끝나지 않았다면 다음 우선순위의 큐로 삽입되어 실행됨 -> 여기서도 작업을 다 마치지 못했다면 그보다 더 낮은 우선순위의 큐로 삽입되어 실행되는 것임

즉, CPU 집중 프로세스의 경우 계속 우선순위가 낮아지게 되는 것임

![](../../README_resources/Pasted%20image%2020240330161518.png)
