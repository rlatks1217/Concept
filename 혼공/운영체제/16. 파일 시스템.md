- 파일 시스템 : 파일이나 디렉토리를 보조기억장치에 일목요연하게 정리하고 또 접근이 가능하게 하는 운영체제 내부 프로그램

### 파티셔닝, 포매팅
- 이제 막 공장에서 생산되어 한 번도 사용된 적 없는 새 하드디스크(ex - SSD)는 파티셔닝, 포매팅을 하기 전에는 사용할 수 없음

다음과 같은 오류 발생

![](../../README_resources/Pasted%20image%2020240517073732.png)

#### 파티셔닝 : 저장 장치의 논리적인 영역을 구획하는 작업
- 보조기억장치를 서랍이라고 했을 때, 여러 물건들을 서랍에 막 넣어놓는 것보다는 칸막이같은 것을 설치하여 담는 것이 훨씬 더 공간을 잘 활용하는 것이라고 할 수 있음
 -> 이처럼 보조기억장치의 영역을 나누는 작업을 **파티셔닝**이라고 함(나눠진 영역들 하나하나를 파티션이라고 함)
 
 Windows에서 파티셔닝된 상태 확인

![](../../README_resources/Pasted%20image%2020240517073805.png)

### 포매팅
- 파일 시스템을 설정하는 작업
- 어떤 방식으로 파일을 저장하고 관리할지 결정, 새로운 데이터를 쓸 준비작업
- 포매팅을 통해서 파일시스템이 구성됨

![](../../README_resources/Pasted%20image%2020240517073827.png)

파일 시스템에는 여러 종류가 있고, 파티션마다 다른 파일 시스템을 설정할 수도 있음

![](../../README_resources/Pasted%20image%2020240517073900.png)

파티셔닝과 포매팅은 동시에 진행되는 경우도 있음

### 파일 할당 방법
- 포매팅까지 끝난 하드 디스크에 파일을 저장하기
- 운영체제는 파일/디렉터리를 블록 단위로 읽고 씀
     - 하나의 파일이 보조기억장치에 저장될 때에는 여러 블록에 걸쳐 저장이 된다는 것을 알 수 있음
     - 하드디스크의 저장 단위 중 가장 작은 단위인 섹터를 묶어 블록으로 만들어 관리하는 것임

![](../../README_resources/Pasted%20image%2020240517073921.png)

- 네모 하나하나가 블록임(블록 안에 숫자는 위치값을 의미함)
- 파일을 보조기억장치에 할당하는 두 가지 방법 : 연속 할당, 불연속 할당

### 연속 할당
- 이름 그대로 보조기억장치 내 연속적인 블록에 걸쳐 파일을 저장
- 연속 할당을 통해 파일을 저장했을 때의 디렉토리 엔트리의 구성 : 파일 이름, 첫 번째 블록 주소, 블록의 단위 길이(해당 파일의 내용을 구성하고 있는 블록의 갯수)

![](../../README_resources/Pasted%20image%2020240517073956.png)

- 연속 할당의 부작용 : 외부 단편화를 야기함

### 불연속 할당 - 연결 할당
- 오늘날 많이 사용하는 파일 할당의 방식
- 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당
- 파일을 이루는 데이터 블록을 연결 리스트로 관리
- 불연속 할당의 장점 : 파일이 여러 블록에 흩어져 저장되어도 무방함

![](../../README_resources/Pasted%20image%2020240517074039.png)

- 연결 할당을 통해 파일을 저장했을 때의 디렉토리 엔트리 구성 : 파일 이름, 해당 파일을 구성하는 블록 중 첫 번째 블록의 주소, 블록의 단위 길이
- 가장 마지막 블록의 경우 다음 블록이 없기 때문에 더이상 읽을 블록이 없다는 의미인 -1과 같은 표시자를 다음 블록의 주소를 담아야 할 곳에 저장하게 됨
- **단점**
	1. 반드시 첫 번째 블록부터 하나씩 읽어야 하므로 속도가 느림
		- Ex) 1, 2, 3 블록이 연결되어 있다고 할 때, 2만 읽고 싶어도 1을 거쳐서 2를 읽어야 함
	2. 오류 발생 시 해당 블록 이후의 블록은 접근할 수 없음(다음 블록에 대한 정보는 이전 블록에 적혀 있기 때문에 오류 발생 시 다음 블록에는 접근할 수 없는 것임)

### 불연속 할당 - 색인 할당
- 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 보아 관리하는 방식
- 하나의 블록에 **특정 파일의 내용을 구성하는 모든 블록에 대한 정보가 있기 때문에** 블록 접근에 용이함
- 색인 할당을 통해 파일을 저장했을 때의 디렉토리 엔트리의 구성 : 파일 이름, 색인 블록 주소

![](../../README_resources/Pasted%20image%2020240517074101.png)

### FAT 파일 시스템
- 연결 할당 기반 파일 시스템
- 연결 할당의 단점을 보안한 방식
- 각 블록에 포함된 다음 블록 주소를 한데 모아 테이블(File Allocation Table)로 관리
- 이 FAT는 파일 시스템 내부에 캐싱될 수 있기 때문에 굳이 보조기억장치를 뒤적거리지 않아도 됨(속도 개선)

![](../../README_resources/Pasted%20image%2020240514073035.png)

- FAT 파일 시스템의 파티션 구성

![](../../README_resources/Pasted%20image%2020240514073142.png)

- 디렉토리 엔트리 구성

![](../../README_resources/Pasted%20image%2020240514073335.png)

- 여기서 속성은 이 파일이 읽기 전용 파일인지, 디렉토리인지, 일반 파일인지 등에 대한 구분을 위한 항목임

26분 FAT 파일 시스템 동작과정 참고

### 유닉스 파일 시스템
- 색인 할당 기반 파일 시스템
- 색인 블록를 i-node라고 부름
	- 이 노드는 파일의 속성 정보와 15개의 블록 주소를 저장할 수 있음
- 기본적으로 파일 시스템은 루트 디렉토리의 위치를 항상 기억하고 있음

![](../../README_resources/Pasted%20image%2020240517074129.png)

![](../../README_resources/Pasted%20image%2020240517074156.png)

15개의 블록보다 파일의 크기가 크다면?
1. 블록 주소 중 12개에는 직접 주소 저장
2. 1번으로 충분하지 않다면 13번째 주소에 단일 간접 블록 주소 저장
     - 단일 간접 블록 : 파일 데이터를 저장한 블록 주소가 저장된 블록

![](../../README_resources/Pasted%20image%2020240517074219.png)

3. 2번으로 충분하지 않다면 14번째 주소에 이중 간접 블록 주소를 저장
    - 이중 간접 블록 : 단일 간접 블록들의 주소를 저장하는 블록

![](../../README_resources/Pasted%20image%2020240517074233.png)

4. 3번으로 충분하지 않다면 15번째 주소에 삼중 간접 블록 주소를 저장
    - 삼중 간접 블록 : 이중 간접 블록들의 주소를 저장하는 블록

![](../../README_resources/Pasted%20image%2020240517074255.png)

![](../../README_resources/Pasted%20image%2020240517074321.png)

34분부터 동작과정 참고

Ntfs, extfs 추가적으로 학습

