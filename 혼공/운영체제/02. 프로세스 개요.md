- 프로세스 : 실행되는 프로그램
- 포그라운드 프로세스 : 사용자가 볼 수 있는 공간에서 실행되는 프로세스 ex) 워드, 게임 등
- 백그라운드 프로세스 : 사용자가 볼 수 없는 공간에서 실행되는 프로세스
	 1. 사용자와 직접 상호작용이 가능한 백그라운드 프로세스
	 2. 사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스(데몬(daemon), 서비스(service) 라고도 부름)

### 프로세스 제어 블록(PCB)
- 모든 프로세스는 실행을 위해선 CPU가 필요함 But CPU는 한정적임 -> 프로세스는 자신에게 할당된 시간만큼만 CPU를 이용하게 됨(즉, 프로그램들이 돌려 쓰는 것)
- 타이머 인터럽트가 발생하면 차례를 양보하게 됨
- 타이머 인터럽트(하드웨어 인터럽트 중 하나) : 할당된 시간이 끝났음을 알려주는 역할의 인터럽트

04:11

- 운영체제는 빠르게 번갈아 수행되는 프로세스들을 일목요연하게 관리해야 함 -> 이를 위해 사용하는 자료구조가 **프로세스 제어 블록**
	- 프로세스 관련 정보를 저장하는 자료구조
	- 마치 상품에 달린 태그와 같이 각 프로세스의 대한 정보가 각각 PCB에 담기게 됨
		- PCB에 담기는 대표적인 정보 : 프로세스ID(PID), 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 정보, 해당 프로세스가 사용한 파일과 입출력 장치 정보 
	- PCB는 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기

06:59

**프로세스 ID**(PID)
- 특정 프로세스를 식별하기 위해 부여하는 번호

**레지스터 값**
- 프로세스는 자신의 실행이 중단되면 그때까지 사용한 PCB에 레지스터 값을 따로 저장함 
-> 다시 자기 차례가 오면 이전의 사용했던 레지스터값들을 사용하던 레지스터들에 복원해서 사용하게 됨
- 이유 : 프로그램을 실행하는 과정에서는 당연히 CPU 내의 레지스터도 이용됨 **->** 해당 프로그램에게 할당된 시간이 끝나면 실행을 중단하고 다시 자신의 차례가 올 때까지 기다려야 함 **->** 지금까지 해당 프로그램을 실행하면서 레지스터들 안에 저장했던 값들을 기억하고 있어야 나중에 자신의 차례가 왔을 때 해당 값들을 가지고 실행을 재개할 수 있음
	
	Ex) 만약 프로그램 카운터(레지스터 중 하나)의 값을 따로 저장해놓지 않는다면 다음 차례가 왔을 때 어디부터 실행하면 되는지 알 수 없음

**프로세스 상태**
- 입출력 장치를 사용하기 위해 기다리는 상태, CPU를 사용하기 위해 기다리는 상태, CPU를 기다리는 상태 등의 상태 정보를 말함

**CPU스케줄링 정보**
- 프로세스가 언제, 어떤 순서로, 얼마만큼의 시간 동안 CPU를 사용할 지에 대한 정보

**메모리 정보**
- 프로세스가 저장된 주소 정보
- 페이지 테이블 정보(나중에 자세히.. 지금은 메모리 주소를 알 수 있는 정보라고만 알고 있기)

**사용한 파일과 입출력장치 정보**
- 해당 프로세스에 할당된 입출력 장치, 사용 중인(열려 있던) 파일 정보

### 문맥 교환(context switch)
- 한 프로세스(A)에서 다른 프로세스(B)로 실행 순서가 넘어간다면?
1. 기존에 실행되던 A는 지금까지의 **중간 정보**를 백업함
2. 뒤이어 실행할 프로세스인 B의 문맥(context)을 복구함

- 중간 정보에 포함되는 것들 : 프로그램 카운터 등 각종 레지스터값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
- 이러한 중간 정보를 문맥(context)라고 함
- 중간 정보는 다음 차례가 왔을 때 실행을 재개하기 위한 정보임

이처럼 기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스의 실행을 위해 복구하는 과정을 문맥 교환(context switching)이라고 함 -> 이게 바로 프로그램들이 번갈아가며 실행되는 원리임

18:30

### 프로세스의 사용자 영역
#### 1. 코드 영역
- 실행할 코드들 즉, 기계어로 이루어진 명령어가 담기는 공간(readOnly 영역임)
#### 2. 데이터 영역
- 프로그램이 실행되는 동안 유지할 데이터를 저장 Ex) 전역변수, 상수 등

위의 두 영역은 크기가 고정되어 있음 -> **정적 할당 영역**이라고도 부름

#### 3. 힙 영역
- 사용자가 사용할 수 있는 저장 공간 ex) 사용자가 생성한 객체 저장
- 자바는 프로그램이 할당받은 메모리를 자동으로 반환해주지만 c언어같이 오래된 언어들은 일일이 메모리를 비워주고 반환하는 작업을 해줘야 함
- 메모리를 비워주지 않으면 메모리에 계속 데이터가 남아 있기 때문에 후에 메모리 낭비를 초래함 -> 이런 현상을 메모리 누수(memory leak)라고 함
#### 4. 스택 영역
- 데이터가 일시적으로 저장되는 공간 ex) 매개변수, 지역변수

위 두 영역은 데이터가 늘어나고 줄어듦에 따라 가변적으로 공간의 크기가 변하기 때문에 **동적 할당 영역**이라고 함

### 힙과 스택의 주소 할당 방식
- 힙 영역은 낮은 주소에서 높은 주소로 데이터가 담길 공간에 대한 주소를 할당함
- 스택 영역은 높은 주소에서 낮은 주소로 데이터가 담길 공간에 대한 주소를 할당함

26:50

이렇게 할당하는 방식으로 설계된 이유 : 공간의 크기가 가변적으로 변하는 영역들이기 때문에 애초에 두 영역이 딱 붙어있게 된다면 아래쪽에 위치한 공간은 커질 수 있는 공간의 한계가 생겨버리므로, 서로 반대지점부터 주소를 할당하기 시작하여 데이터가 늘어감에 따라 영역이 커지는 방식으로 설계된 것