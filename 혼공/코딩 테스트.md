### 약수 / 소수 구하기
n까지의 약수 혹은 소수를 구한다고 할 때 n의 제곱근까지만 체크해도 되는 이유
- n = a * b라고 했을 때 a가 b보다 작다면 a는 n의 제곱근보다 클 수 없다. (a가 가장 커지는 시점은 b와 같을 때 즉, n의 제곱근과 같을 때이기 때문에) 
- 그렇기 때문에 a를 구하려고 한다면 1부터 a의 최대값이 될 수 있는 n의 제곱근까지만 체그해주면 되는 것이다.

### 큐(Queue)의 개념
- FIFO(First In First Out) 선입선출의 구조를 가짐
ex) 은행에서 먼저 번호표 뽑은 사람이 먼저 업무를 보는 것을 생각하면 됨

### Linked List 개념
![](Pasted%20image%2020230502184215.png)
- 이런 형태의 자료구조임
- 즉, 메모리 상에는 다 따로 떨어져 있지만 서로 다음 값에 대한 주소를 짝꿍처럼 가지고 있어 연결이 되는 형태라고 할 수 있음

##### Linked List가 Array List에 비해 좋은 점
- 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간에 수행할 수 있음
`ArrayList의 삽입 과정`
1. 삽입될 자료를 기준으로 뒤의 데이터를 전부 한칸씩 밀어냄
2. 해당 위치에 원하는 데이터를 입력
`ArrayList의 삭제 과정`
1. 삭제될 자료가 위치한 인덱스의 자료를 삭제함
2. 삭제된 자리 뒤에 있는 데이터들을 한칸씩 당김

`Linked List의 삽입 과정`
1. A와 B 사이에 데이터를 추가한다고 했을 때 추가될 자료의 node(주소값을 담는 칸) 생성
2. A의 node에 다음 주소값을 해당 자료의 주소값으로 바꾸고
3. B의 이전 node에 이전 주소값을 해당 자료의 주소값으로 바꿈

- ArrayList와는 다르게 자료를 무한대로 삽입할 수 있음(ArrayList는 한정되어 있음)

 단점으로는 검색할 때 ArrayList에 비해 느리다는 것

### 기본 for문 for-each문
기본 for문은 배열이나 컬렉션의 길이(length())를 구하고, 인덱스를 증가시키며 반복하는 과정이 필요함. 이 과정에서 불필요한 계산과 연산이 많이 발생할 수 있다고 함. 반면에 for each문은 컬렉션에 대한 이터레이터를 사용하여 각 요소에 접근하므로, 반복할 때마다 인덱스를 구하거나, 인덱스 변수를 업데이트 하는 과정이 필요하지 않기 때문에 더 빠른 것

### BFS와 DFS의 기초 개념
- 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말함
- 대표적인 그래프 탐색 알고리즘이 BFS와 DFS임

`Stack`
- 가장 먼저 들어온 데이터가 가장 나중에 나가는 (FILO) 형식의 자료구조임
ex) 박스 쌓기, 프링글스 과자통
![](Pasted%20image%2020230508102033.png)
![](Pasted%20image%2020230508102527.png)
s.peek() : 스택의 최상단 자료를 반환만 하는 메소드(삭제는 아님)
s.pop() : 스택의 최상단 자료를 반환하고 stack에서 해당 자료를 삭제하는 메소드

`Queue`
- 가장 먼저 들어온 데이터가 먼저 나가는(FIFO) 형식의 자료구조
ex) 터널
![](Pasted%20image%2020230508104026.png)
- 삭제 연산을 수행할 때는 5, 2, 3, 7 순서로 삭제가 이뤄지게 됨
![](Pasted%20image%2020230508104246.png)
q.offer(숫자) : 자료구조에 데이터 집어넣기
q.poll() : 데이터 하나씩 꺼내기

`재귀함수` : Recursive Function
- 자기 함수를 다시 호출하는 함수를 의미
- 제한 없이 계속 출력하게 될 경우 StackOverflowError가 발생하게 됨
- stack 자료구조처럼 처음 실행했던 함수가 가장 마지막에 종료됨
- 모든 재귀함수는 반복문을 이용하여 동일한 기능을 구현할 수 있음
- stack을 이용해야 할 경우 stack 대신 재귀함수를 이용하는 경우가 많음(즉, 자바 내부의 메소드들이 쌓이는 stack을 이용하는 것임)

`유클리드호제법`
- 호제법 : 두 수가 서로 상대방 수를 나누어 결국 원하는 수를 얻는 알고리즘을 일컫는 말
- 2개의 자연수 a, b(a>b)에 대하여 a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대 공약수와 같음
- b와 r의 최대공약수 또한 위의 방법에 따라 b를 r로 나눈 나머지와 r과 해당 나머지의 최대공약수와 같음을 통해 구할 수 있음 => 계속 이러한 과정을 반복하게 되면 비교적 작은 수들을 통해서 최대공약수를 구할 수 있음을 알 수 있음
- 같은 연산과정이 반복되므로 재귀함수를 통해 구할 수 있음
- GCD : 최대공약수를 의미함

### DFS : 깊이 우선 탐색
- 그래프(노드와 간선으로 이뤄진 자료구조)에서 깊은 부분을 우선으로 탐색하는 알고리즘
- 노드 : 그래프의 한 지점
- 간선 : 노드 간의 연결선

- DFS는 스택 자료구조(혹은 재귀함수)를 이용하며, 구체적인 동작 과정은 다음과 같음
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 함
2. 스택의 최상단 노드(가장 마지막에 들어간 놈)에 방문하지 않는 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리/ 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복함

- 여러 인접노드가 있을 경우 인접노드 중 어떤 노드를 먼저 방문할 지 기준이 있어야 되는 경우와 그렇지 않은 경우가 있음(대부분 전자의 경우가 많음)

![](Pasted%20image%2020230508121426.png)
위 예시는 기준이 번호가 낮은 인접노드부터일 경우로 가정함 

- 다음과 같이 1, 7, 2, 6순으로 방문하게 됨(가장 깊은 곳까지)
- 방문하지 않은 노드가 더이상 없을 경우 최상단에 있는 노드(6)을 꺼내고 다시 방문과정을 진행함=> 다음 순서는 당연히 8임 
  => 8까지 방문한 후에는 더이상 깊이 내려가서 방문할 노드가 없으므로 8을 꺼내게 됨 
  => 7에서도 더이상 방문할 노드가 없으므로 꺼냄
  => 2에서도 더이상 방문할 노드가 없으므로 꺼냄 
  => 마지막 1로 돌아와서 방문하지 않은 3을 스택에 넣으면서 다시 다른 방향으로 방문을 시작함 => 이런 식으로 전체 그래프에서 더이상 방문하지 않은 노드가 없을 때까지 반복

![](Pasted%20image%2020230508123145.png)
  index 0은 사용하지 않기 위해서 노드의 갯수보다 하나 많은 길이로 방문여부를 체크할 배열 생성

### BFS : 너비 우선 탐색
- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- Queue 자료구조를 이용하고 구체적인 동작 과정은 다음과 같음
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 함
2. !큐에서 인접노드를 처리할 노드를 꺼낸 뒤에! 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 함
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복함
![](Pasted%20image%2020230508161839.png)
- 위와 같이 3을 먼저 꺼내고 3의 인접노드 중 방문하지 않는 노드들을 큐에 집어넣고(인접노드라도 할지라도 이미 방문한 노드는 집어넣는 것이 아님) 방문처리를 함
- 인접노드들이 방문을 모두 한 경우 해당 노드를 꺼내기만 하면 됨

### 정규식
- 문자열 데이터 중에서 원하는 패턴과 일치하는 문자열 부분을 찾아내기 위해 사용되는 것으로 미리 정의된 기호와 문자를 이용해서 작성한 문자열을 말한다.
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%95%EA%B7%9C%EC%8B%9DRegular-Expression-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%A0%95%EB%A6%AC
- ^의 의미 : ^뒤에 나오는 정규식 패턴으로 문자열이 시작되는지를 확인
- $의 의미 : $ 앞에 나오는 정규식 패턴으로 문자열이 끝나는지를 확인
- * 의 의미 : * 앞의 패턴이 전체 문자열에서 `0번` 부터 여러 번도 나올 수 있게 설정해주는 것 (횟수는 한 글자마다 세는 것이다. 즉, 전체문자열을 한 글자씩 봤을 때 * 앞의 패턴이 나타나면 한 번 나타났다고 보는 것이다.)
- + 의 의미 : + 앞의 패턴이 전체 문자열에서 `1번`부터 아니라 여러 번도 나올 수 있게 
- 각각의 의미는 이렇지만 실제로 함께 썼을 때는 그 의미가 조금 달라짐

- ^와 $를 같이 쓰게 되면 처음부터 끝까지 해당 정규식의 패턴을 이루는가? 를 판단하는 정규식 문자열이 됨/ 단, * 를 쓰지 않게 되면 한글자이면서 해당 정규식 패턴인지를 판단하게 됨
-->그래서 여러 글자로 구성된 단어를 판단할 때는 ^, * , $를 같이 써야 해당 정규식으로만 구성된 단어인지 판단할 수 있음
ex) ^[0-9] * $와 같이 작성하게 되면 숫자로만 이루어져 있는지를 판단할 수 있다
(같은 의미로 [0-9]+로 쓸 수도 있음)

### 행렬곱
- 행렬 곱셈의 조건 : 행렬 A와 B를 곱할 때 A의 열의 개수와 B의 행의 개수가 같아야 함
- 결과 행렬은 (A의 행 x B의 열)이 됨


### N^2배열자르기
- 해당 2차원 배열을 직접 만들어서 해결하면 메모리초과가 날 것임
- 1차원 배열에서만 처리를 해야 하는데 그러면 어떻게 해야 하는가?
1. 각 인덱스(i)마다 /n을 해주면 해당 값이 몇 번째 행인지가 나옴
2. 각 인덱스(i)마다 %n를 해주면 해당 값이 몇 번째 열인지가 나옴
3. 문제에 대입해 보면 (left+1)/n과 (left+1)/n를 구해준다(왜? 실제로 2차원의 각 행을 일렬(1차원 배열)로 쭉 늘어뜨렸을 때 찾으려는 값(자르기 시작할 인덱스의 값)이 left+1이기 때문이다. / 인덱스는 0부터 시작이지만 n은 1부터 시작이므로 1을 더해준 값이 실제 값일 것이다.)

그런데 실제로 2차원 배열안의 각 값들이 어떤 식으로 채워지는지를 상상해보면
![](Pasted%20image%2020230524151401.png)
- 이렇게 오른쪽 끝과 아랫쪽 끝은 모두 같은 숫자를 이루는 형태로 채워질 것(즉, 오른쪽 끝과 아랫쪽 끝에 속하는 숫자는 모두 같은 숫자일 것임) => 몇번째 행이냐 or 몇번째 열이냐 가 곧 해당 값일 것임(+행, 열 = 해당 값임을 이용)

- 2차원 배열의 각 값들의 위치를 봤을 때  해당 자르기 시작하는 인덱스의 값에 대한 행과 열 중 더 바깥쪽 즉, 더 큰 쪽의 속하는 숫자가 해당 값임을 알 수 있음 => 그래서 더 큰 값이 곧 찾으려는 값이 되는 것