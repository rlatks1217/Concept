### 상수
- 변경되지 않는 값
- 클래스나 인터페이스 내에서 유일한 값을 할당하기 위해 사용함(final 키워드 붙임)
- final variables, arguments : 값이 변경되지 않도록 만듬
- final class : 클래스를 상속하지 못하도록 만듬
- final method : 메소드가 override되지 못하도록 만듬

그래서 한 클래스 내에서 final 변수의 중복을 피하기 위해서는 다음과 같이 변수를 달리해야 함
![](Pasted%20image%2020231024160558.png)
다른 방법으로 서로 다른 인터페이스에서 선언하는 것으로도 중복을 피할 수 있음
![](Pasted%20image%2020231024160520.png)
상수는 각각의 의미를 부여하여 사용하기 때문에 똑같은 숫자 데이터라고 해서 아래와 같이 크기를 비교하는 건 본래의 의도에 어긋나는 것임
![](Pasted%20image%2020231025000545.png)
- 의도에 어긋나는 코드는 제한하는 게 맞다고 함. 그렇다면 애초에 이런 쓰잘데기 없는 비교를 방지하려면 어떻게 해야 하는가?
--> 다른 데이터 타입이 되도록 각각을 개별적인 객체로 만들면 됨(다른 데이터 타입간의 비교는 불가능하므로 컴파일 단계에서 오류를 발견할 수 있게 됨 )
- 하지만 이럴 경우 switch문에서는 인자로 사용할 수 없음 - 객체는 원래 switch문에 사용이 안 됨
--> 그래서 사용하기 시작한 게 enum임(열거형이라고도 부름)

### enum
- 사실상 인터페이스와 마찬가지로 특수한 형태의 클래스임(그래서 상수 이외의 필드, 메소드도 충분히 가질 수 있음)
- 서로 연관된 상수들의 집합을 의미함(비슷한 의미의 상수끼리 묶어놓은 것)
- 자바 1.5부터 지원하기 시작함
- enum을 사용하면 아래와 같이 훨씬 간단하게 작성이 가능해짐
![](Pasted%20image%2020231025003259.png)
`여기서의 APPLE은 private final static Fruit APPLE = new Fruit(); 과 같은 의미를 가짐 즉, 각각 다 객체임`
- switch문에서도 사용이 가능함
- 상속이나 인스턴스화가 불가능함(본래의 의도를 해치는 행위라고 판단하여 개발자가 제한함)
- enum 안의 상수들은 각각 객체이므로 생성될 때 생성자를 호출함
- 생성 시점은 처음 상수가 사용되는(=참조되는) 시점에 해당 enum 안의 모든 상수들이 다 생성됨.(정확히는 참조되는 시점에 enum이 클래스 로더에 의해 로드되면서 상수들이 생성되는 것) 
이 때, 생성자는 상수의 갯수만큼 호출될 것임(당연히 호출되는 생성자를 이용해서 enum 내의 필드를 초기화하는 것도 가능함)
![](Pasted%20image%2020231025005643.png)
- values() 를 통해서 반복처리도 가능함
![](Pasted%20image%2020231025010619.png)
- static 블럭의 실행과 같은 시점에 상수들이 생성되므로 상수 생성과 static블럭이 동시에 실행되도록 냅두면 상수의 생성이 제대로 안 될 우려가 있다고 함 그래서 static블럭은 상수 선언 위치보다 위에 있으면 컴파일 오류(빨간 밑줄 쫙)가 나도록 설계됨
- `A("헤헤")`는 new 키워드만 없는 거지 그냥 객체 생성하는 코드랑 똑같다고 보면 됨 즉, "헤헤"가 생성자의 인자로 들어가는 것임 -> 당연히 해당 인자 받아서 필드로 할당하는 게 가능하지
- 결국 enum의 사용이유는 위에서 언급한 본래의 의도로만 사용되도록 하는 것과 가독성을 높이기 위해 사용하는 것
- enum의 scope는 해당 enum class 안에만 국한되는 것이 아니라 프로그램 전역적으로 영향을 미침 -> enum에서 정의한 상수명은 다른 클래스에서 정의할 수 없음

##### 그동안 잘못 알고 있던 사실
- 아래의 그림처럼 각 클래스가 인스턴스로 생성되는 시점에 각자 **로드**되고(static 시점) **생성**되는 방식임
Ex) 
new A(); -> A클래스 로드 후 A인스턴스 생성
new B(); -> B클래스 로드 후 B인스턴스 생성
new C(); -> C클래스 로드 후 C인스턴스 생성

- main 메소드 역시 Test 클래스 안에 있으므로 Test 클래스가 로드되고 실행되는 것임
- 즉, 그 동안 내가 프로젝트 내에 만든 모든 클래스가 다 로드되는 시점이 따로 있고, 모든 객체는 그 이후에 생성된다는 생각은 잘못되었음.
![](Pasted%20image%2020231027001416.png)
- 출력 결과
![](Pasted%20image%2020231027001837.png)