### 상수
- 변경되지 않는 값
- 클래스나 인터페이스 내에서 유일한 값을 할당하기 위해 사용함(final 키워드 붙임)
- final variables, arguments : 값이 변경되지 않도록 만듬
- final class : 클래스를 상속하지 못하도록 만듬
- final method : 메소드가 override되지 못하도록 만듬

그래서 한 클래스 내에서 final 변수의 중복을 피하기 위해서는 다음과 같이 변수를 달리해야 함
![](Pasted%20image%2020231024160558.png)
다른 방법으로 서로 다른 인터페이스에서 선언하는 것으로도 중복을 피할 수 있음
![](Pasted%20image%2020231024160520.png)
상수는 각각의 의미를 부여하여 사용하기 때문에 똑같은 숫자 데이터라고 해서 아래와 같이 크기를 비교하는 건 본래의 의도에 어긋나는 것임
![](Pasted%20image%2020231025000545.png)
- 의도에 어긋나는 코드는 제한하는 게 맞다고 함. 그렇다면 애초에 이런 쓰잘데기 없는 비교를 방지하려면 어떻게 해야 하는가?
--> 다른 데이터 타입이 되도록 각각을 개별적인 객체로 만들면 됨(다른 데이터 타입간의 비교는 불가능하므로 컴파일 단계에서 오류를 발견할 수 있게 됨 )
- 하지만 이럴 경우 switch문에서는 인자로 사용할 수 없음 - 객체는 원래 switch문에 사용이 안 됨
--> 그래서 사용하기 시작한 게 enum임(열거형이라고도 부름)

### enum
- 사실상 인터페이스와 마찬가지로 특수한 형태의 클래스임(그래서 상수 이외의 필드, 메소드도 충분히 가질 수 있음)
- 서로 연관된 상수들의 집합을 의미함(비슷한 의미의 상수끼리 묶어놓은 것)
- 자바 1.5부터 지원하기 시작함
- enum을 사용하면 아래와 같이 훨씬 간단하게 작성이 가능해짐
![](Pasted%20image%2020231025003259.png)
`여기서의 APPLE은 private final static Fruit APPLE = new Fruit(); 과 같은 의미를 가짐 즉, 각각 다 객체임`
- switch문에서도 사용이 가능함
- 상속이나 인스턴스화가 불가능함(본래의 의도를 해치는 행위라고 판단하여 개발자가 제한함)
- enum 안의 상수들은 각각 객체이므로 생성될 때 생성자를 호출함/ 생성 시점은 처음 상수가 사용되는 시점에 해당 enum 안의 모든 상수들이 다 생성됨. 이 때, 생성자는 상수의 갯수만큼 호출될 것임(당연히 호출되는 생성자를 이용해서 enum 내의 필드를 초기화하는 것도 가능함)
![](Pasted%20image%2020231025005643.png)
- values() 를 통해서 반복처리도 가능함
![](Pasted%20image%2020231025010619.png)