생성자 오버로딩 - 필드를 다양한 형태로 초기화를 하기 위해 사용
private - 직접적인 접근은 허용 x (간접적인 접근을 하라는 의도) --> information hiding
method - 비즈니스 로직을 처리

### JVM 메모리 구조
1. Method Area : class 자체에 대한 정보가 올라가는 곳
- static variable(static이 붙은 field/모든 instance가 공유할 수 있는 변수)은 여기에 class 정보가 올라가는 시점에 공간이 생성
2. Stack : constructor or Method가 실행(호출)되기 시작하면 여기에 일정 공간을 차지하면서 쌓임
- 이 차지하는 공간 안에는 지역변수가 변수를 위한 공간을 만들어 들어가게 됨
3. Heap : instance라고 불리는 건 무조건 Heap에 적재

Method Overloading : 여러 타입이나 갯수의 인자를 받아 로직처리를 하기 위해서 사용
Package & import : 패키지를 사용하는 이유는 유지보수와 재활용을 편리하기 위해(비슷한 것끼리 묶어서 모아 놓으면 편리하니까)
원래는 클래스를 사용할 때 클래스 앞에 'package명.'을 붙여줘야 함 
--> 편의성을 위해 import를 사용하기 시작함(심지어 이거를 안 써줬을 때 자바가 알아서 넣어주는 패키지도 존재함

### Access Modifier
public - 아무데서나 사용 가능(보통 Method는 이 접근제어자로 정의함)
protected - 기본은 default와 같음(같은 패키지 내에서만 접근이 가능)
(단, 다른 패키지에 해당 클래스와 상속관계에 있는 클래스가 있을 경우에는 사용이 가능) 
package(default) - 같은 패키지 내에서만 접근이 가능
private - 해당 클래스 내부를 제외하곤 직접적인 접근 못함

Inheritance - 기존의 클래스를 확장해서(이어받아서) 새로운 클래스를 정의하는 방법
(상위 클래스의 내용이 바뀌면 하위클래스의 내용도 바뀌게 됨)
Java의 모든 클래스는 상속관계에 있음
tightly coupled - 상속관계에 있는 클래스들은 서로 한 몸처럼 움직임
--> 객체의 단위는 기본적으로 재활용 단위는 개별 클래스인데 나중에는 상속에 의해서 그 관계에 있는 모든 클래스들을 통째로 들고 다녀야 되는 것이 비효율적인 문제가 발생함(= 개별 클래스만 재활용하고 싶은데 다른 것들도 묶여있기 때문에 한번에 가져와야 되는 거지)

Method overriding : 상위 클래스의 method를 하위 class에서 다시 정의
- method 형태는 똑같고 대신 로직처리를 상황에 맞게 변경이 가능

### IS - A 관계(IS - A relationship)
SubClass is SuperClass (정의) : 역은 성립하지 않음(의미일 뿐)
--> 코드 상에서는 subclass의 type을 써야 하는 곳에 superclass type을 대신 쓸 수 있음
 - 객체지향의 다형성

### final keword가 붙을 수 있는 곳
1. 클래스 ex) pubilc final class A
- 상속의 계층의 가장 아래에 위치(자식 인스턴스가 더 이상 없음)
--> 이 class를 이용해서 새로운 클래스를 확장시킬 수 없음
2. field 즉, field의 값을 더이상 바꿀 수 없게끔 만들고 값을 고정시킴 --> '상수화' 
- final을 할 경우 초기값은 반드시 지정해줘야 함(default로 초기화되게 두면 안 됨) 
3. method
- 하위 클래스에서 해당 method를 override할 수 없음

추상클래스 사용 이유 - 협업을 하는데 서로 다른 사람들이 각자 다른 클래스에 같은 기능을 정의하는  데 이름이 달라버리면 나중에 유지보수하는 데에 굉장히 어려워짐 
추상 클래스(Abstract Class) - 클래스 내에 abstract method가 단 1개라도 있으면 추상 클래스라고 함

method의 정의 - 구현부(중괄호 안)에 아무것도 없이 써줘도 정의했다고 표현함
--> 이 method는 아무것도 하지 않는 임무를 수행하는 메소드라고 보는 거임
ex) public void eat() {(공백)}

선언 - 아직 어떤 기능을 할 지는 정하지 않았지만 메소드 이름은 정해준 것(정의랑은 다름)
추상메소드 - method인데 method의 하는 일을 명시하지 않음(=구현부를 작성하지 않음=메소드이름만 정해준 것(중괄호 없이))
method가 아직 완전히 안 만들어졌기 때문에 그 method를 포함하고 있는 클래스도 불완전해지는 것
--> 그래서 추상 메소드가 1개라도 있으면 추상 클래스가 되는 거임
즉, 추상 클래스는 불완전하기 때문에 인스턴스를 만들어낼 수 없음

이 추상 클래스를 상속해서 새로운 하위클래스를 만듬(이 새로운 클래스도 마찬가지로 추상클래스가 됨 --> 추상 클래스를 이어받았기 때문에 --> 만약 override을 사용해서 추상 메소드를 완전한 메소드로 재정의한다면 해당 하위클래스는 완전한 클래스가 됨 --> 인스턴스를 만들 수 있게 됨)

이 하위클래스로 인스턴스를 만들 경우 상속받은 클래스 중 가장 상위의 클래스부터 인스턴스가 만들어지는데 추상 클래스 부분 역시 인스턴스로 만들어지긴 함(당연히 주소값도 존재) 하지만 그 클래스에 포함되어 있는 메소드는 불완전하기 때문에 가장 하위 클래스에서 super 키워드를 사용하여 호출할 수 없음 즉, 오버라이딩된 메소드만 사용할 수 있는 거임(하지만 추상메소드가 속해있는 클래스타입으로 해당 메소드를 호출한다고 해도 이미 오버라이딩해줬기 때문에 오버라이딩된 메소드가 호출되게 됨)

getter & setter : 상속하여 내포하고 있다고 하더라고 하위 인스턴스에서 상위 클래스의 private 필드에 접근할 때는 다른 클래스에 접근하는 것이기 때문에 써야 함
(단, 따로 참조변수를 통해 접근할 필요는 없음 - 내포하고 있기 때문)

2개의 클래스가 한 클래스를 상속하더라도 객체는 각각 생성되기 때문에 내부에 상위 클래스의 객체는 각각 생성된다고 볼 수 있다.

interface - 클래스 간의 결합도를 낮출 수 있음

인터페이스는 클래스의 아주 특별한 형태임
public interface A {
생성자가 없음 --> 인스턴스 못 만든다.
(public static final) 필드 = ~~ ; public static final 무조건 이게 붙음 그래서 이 부분 생략 가능
--> getter & setter 안 나옴 왜냐? public이면서 바꿀 수도 없으니까

무조건 Abstract 메소드만 나옴 --> 추상 메소드로만 이뤄져있다고 할 수 있음
}

클래스 간에는 무조건 상속이 가능함
interface끼리는 서로 상속이 가능함

클래스는 인터페이스를 상속할 수 없음
대신 클래스는 인터페이스를 구현할 수 있음 (표현의 차이 정도라고 이해하자)
인터페이스끼리도 똑같이 IS-A 관계 성립
다중 구현을 허용함(구현만 다중으로 되는 거임(상속은 안돼!))
 --> 오버라이딩해서 기능을 추가하고 싶은데 여러 클래스를 일일이 상속해서 오버라이딩 하기 힘드니까 하기 시작함
ex) class B implements B, C