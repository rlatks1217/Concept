![](Pasted%20image%2020231014200332.png)
1. equals() - 객체를 비교하는 용도(기본적으로는 참조값 비교하는 메소드 - 하지만 override를 통해 내용물 비교하는 메소드로 바꿔씀 - > String 클래스 같은 경우 기본적으로 override된 메소드를 제공)
2. toString() - 객체를 문자열로 표현할때 +사용

자바에선 한 글자와 여러 글자는 완전히 다르다.(Char와 String으로 데이터타입이 구분됨)

### String Class - Reference Data Type
![](Pasted%20image%2020231014200403.png)
즉, 문자열은 객체임 -> 클래스가 있고 당연히 필드+메소드가 있음
- String a  = new String("안녕"); 원래는 이런 식으로 객체를 만들어야 함(이렇게 만들었을 경우에는 String pool이 아니라 일반적인 Heap 안에 생성됨)
- String b = "안녕"; 하지만 문자열은 너무나 많이 쓰기 때문에 이렇게 써도 객체 생성이 되도록 허용해줌 --> Heap 안에 String pool이 존재 : 이 안에는 문자열만 들어감(그래서 String b = "안녕"; 로 인스턴스 생성 시 String pool 안에 들어가게 됨)
- String c = "안녕"; 이렇게 같은 값을 가진 인스턴스를 또 만들려고 하면 일단 String pool에서 해당 문자열이 있는지 확인(기존의 해당 내용물의 객체를 new로만 만들었으면 String pool에 새로 만들겠지) 
--> 있으면 그 객체의 주소값을 저장하고 없으면 새로 만듬(같은 문자열을 너무 많이 새로 만들어 사용하게 되면 Heap에 공간이 부족해짐.. 그래서 이런 방식으로 만들게 함) 
--> 그래서 같은 객체를 가리키고 있으면 같은 문자열을 가지고 있다는 걸 의미하게 되므로 `==`연산자를 사용해도 됨(그러나, 객체를 비교할 땐 equals를 사용함 --> because `==`의 경우 기존에 있던 객체와 새로 만든 객체에 대해서는 같은 내용물을 가지고 있더라도 false를 반환하게 되므로)
- pool - 프로그래밍에서 객체들이 모여있는 공간을 의미

String 클래스 역시 Object를 상속하는데 equals메소드를 이 클래스에서는 객체의 내용물을 비교하도록 override해서 우리에게 제공함
String 인스턴스의 필드를 접근할 때는 다른 객체와는 다르게 그냥 참조변수만 써도 자동으로 접근됨
(String클래스의 메소드는 .메소드명() 이렇게 접근해야 함)

### String의 또다른 특징
immutable(불변의) : 문자열간 결합을 하는 경우 String(문자열)객체 자체는 변하지 않음(기존에 있던 인스턴스는 그대로 있음 --> !!결합한 새로운 문자열을 따로 인스턴스로 만듬!!)

### Array(배열)
- 거의 대부분의 프로그래밍 언어가 가지고 있는 기본 자료구조
- 배열 안에는 객체의 경우 객체의 주소값이 들어감
특징
1. 여러개의 연속적인 저장공간
2. 배열 역시 객체
3. 배열 사용은 index를 사용(0부터 시작) - 반복처리할 때 편함
4. 각각의 저장공간은 (같은 데이터타입)을 가짐
5. 한번 사이즈가 결정되면 그 사이즈는 고정임(사이즈가 다른 배열은 새로 만들어야 함)

### 배열의 단점
1. 같은 데이터타입만 들어감
2. 사이즈가 고정적임

### 해결방안
ArrayList class(자바가 제공하는 Java.util package 안에 있음)
1. 서로 다른 dataType의 데이터를 저장
2. 배열과 유사하게 생김
3. 크기가 고정되어 있지 않고 저장되는 만큼 늘어날 수 있음
4. 이 안에는 Reference Data Type 즉, 인스턴스만 저장할 수 있음(primitive Data Type은 저장 못해)

4번의 단점을 해결하기 위해 Wrapper Class를 제공
(primitive Data Type을 객체 형태로 쓸 수 있도록 감싸주는 클래스)
ex) Int k = 100; --> Integer k = new Integer(100); : 정수 100을 가지고 있는 인스턴스를 생성하게 되는 것

ArrayList는 원래 다른 데이터타입도 들어갈 수 있지만 보통 하나의 타입으로 고정해서 저장하는 것이 좋다고 함 

- **Generic** :  컴파일 시 타입을 채크해 주는 기능
![](Pasted%20image%2020231018172051.png)
Generic이 있기 전에는 이처럼 아무 DataType이나 넣어도 에러가 안 남 
=> 잘못된 DataType이 들어가도 잡을 수 없음 
=> 하지만 Generic이 생긴 후부터는 원하는 데이터타입만 집어넣을 수 있게 되었음

또한, 원래는 add()를 사용할 때마다 `list.add((Integer)10);` 와 같이 형변환을 해주고 넣어줬어야 함 하지만, 컴파일러가 알아서 형변환을 해주므로 형변환 과정을 생략하고 사용하던 것임

- 자리표시자 : <T>, <E>, <N> 등과 같은 것은 컬렉션(List나 Set, Map)의 타입을 고정하지 않겠다는 의미로 사용함 => 데이터의 타입은 고정하지 않은 채 틀만 정해두기 위해 사용함(이렇게 하면 같은 흐름(로직)으로 여러 타입의 데이터를 처리할 수 있음) 그래서 주로 클래스나 메소드에 사용됨
- 각 자리표시자에 부여된 의미(가독성을 위해 부여한 의미)는 다르지만 기능이 다르진 않음