![](../../../README_resources/Pasted%20image%2020231014195417.png)
- 기존의 class를 정의할 때 기존의 다른 class의 내용을 이어받아 확장해서 class를 정의하는 방법
- class의 재활용성을 높일 수 있음(재활용성 - 클래스를 만들 때 새로 만드는 것이 아닌 기존에 있던 방식에서 이어서 만들 수가 있다는 것을 의미)

Person(클래스) <-- Student(클래스) : Student클래스가 Person클래스를 상속한다는 의미

상속은 결국 트리구조를 이룸(Object가 가장 상위)
Person - super class, 상위 클래스, Parent class, 부모 클래스, upper class
Student - sub class, 하위 클래스, child class, 자식 클래스 

### IS - A relationship (IS - A 관계)
![](../../../README_resources/Pasted%20image%2020231014195758.png)
Sub class is a Super class : 역은 성립하지 않음  : 포함관계 SubClass 밖/ SuperClass 안
--> ex) 포유류(super class) <-- 사람 고래 강아지 (sub class들) =>그림으로 그려보면 트리구조
즉, 정의를 봤을 때 의미적으로 'SubClass는 SuperClass다' 니까 SuperClass를 SubClass 대신 변수타입으로 사용할 수 있음(매개변수를 포함)을 의미/하지만 역은 성립하지 않으므로 SubClass를 SuperClass 대신에 사용할 수는 없음

초기화하는 역할을 하는 constructor는 상속받을 수 없음 --> 단 자식 생성자에서 부모 생성자 호출은 가능(super();) - 자식 생성자 호출 시 제일 먼저 다른 내용보다 super();을 하게 됨
private(접근제어자)로 묶여 있으면 상속받을 수 없음

상속이 사용된 경우 Method Area에 Person이라는 클래스의 정보부터 올라가게 됨(Student는 Person의 내용을 이어받아 만들어진 클래스니까 Person부터 알아야지)그 다음 Student가 올라가게 되는 것

Java의 최상위 Class = Object Class --> 모든 자바의 클래스는 Object 클래스를 상속한다.
![](../../../README_resources/Pasted%20image%2020231014195650.png)
--> 자바의 모든 클래스는 상속관계에 있다
--> ★그래서 사실 모든 인스턴스를 만들게 되면 Object 인스턴스(상속받는 인스턴스)를 먼저 만들고 만들게 됨★
(자식instance를 만들려고 클래스를 찾아가 보니 부모 클래스의 내용이 있어서 부모instance를 먼저 만들고 그것을 포함하는 자식instance의 형태로 객체를 만드는 식 - 그래서 사실은 포함관계인 것)
- 주소값 역시 사실 상속받는 부모의 수만큼 더 만들어짐(애초에 안쪽부터 인스턴스 여러 개가 감싸는 형태로 만들어지는 거니까 당연한 것) 
--> 그래서 변수의 타입이 부모 타입으로 바뀌게 되면 주소값이 자식 인스턴스 안에 만들어진 부모 인스턴스의 주소값으로 바뀌게 되므로 기능이나 데이터를 사용하는데에 제약이 생김(범위 밖인 자식 인스턴스에 소속된 메소드는 사용할 수 없게 되는 것임)

따라서 DataType에 따라서 객체는 여러 형태로 지정할 수 있음 = 여러 클래스의 참조변수로 참조할 수 있음(객체 지향의 다형성이라고 함)

### 인스턴스 생성 시
- 생성자의 역할 - 상위 class의 생성자를 super();을 이용해서 호출하는 일을 가장 먼저 진행 / 그 다음 필드를 위한 공간의 확보 후 초기화 작업이 이뤄지게 됨
- this(키워드) - 현재 사용중인 객체를 가리키는(참조하는) 변수
- super(키워드) - this가 가리키는 객체의 상위 Type 객체를 참조하는 변수

인스턴스 내에는 메소드의 실제 실행코드는 없고 링크처럼 포인터(참조변수)만 있음
그래서 실행할 때는 링크를 이용해 Method Area에 있는 실제코드로 찾아가서 실행하게 됨

- 배열 - 같은 데이터 Type으로 되어 있는 연속적인 저장공간
사실 Java는 array보다는 ArrayList와 같은 collection계열을 이용

- 두 클래스가 상속 관계일 때 자식 클래스와 부모 클래스에 같은 이름의 필드가 있다면 부모  클래스의 메소드로 해당 이름의 필드를 변경하는 경우 부모 클래스의 필드가 변경되고, 자식 클래스의 메소드로 해당 이름의 필드를 변경하는 경우 자식 클래스의 필드가 변경될 것(오버라이딩한 경우 일반적으로 자식 클래스의 메소드가 호출될 것이므로 자식 클래스의 필드가 바뀌겠지)