메모리의 주소값을 저장하는 변수 : 포인터

클래스에서
변수는 field
함수는 method

클래스(ADT) --> 인스턴스(생성자를 통해) - 객체라는 표현과 혼용해서 쓴다

### 클래스
1. 객체 모델링의 수단
2. ADT(현실세계의 물체를 임의로 간단하게 표현한 것이 클래스이므로)
3. 인스턴스를 생성하기 위한 수단

### package
- 논리적인 개념(유사한 클래스들을 묶어서 관리)
- 계층구조를 이룸(도메인의 역순으로 이름 설정 ex - kr.or.kosa.패키지명) 물리적인 개념으로는 folder를 의미
- 패키지를 따로 지정해주지 않은 클래스는 default 패키지에 포함되게 됨 즉, 패키지에 포함되지 않는 클래스는 없다.

사실 그래서 클래스를 사용할 때는 (패키지명.클래스명) 이런 식으로 명시를 해주는 것이 맞음 --> 코드가 너무 길어지는 문제로 import를 개발해 사용하기 시작함


### 데이터 타입
##### 1. Primitive Data Type(기본형 데이터 타입) 
- byte short int long (정수형)
- float double (실수형)
- char(1개 글자) boolean(참거짓)
2. Reference Data Type(참조형 데이터 타입) = 클래스

- new(인스턴스를 만드는 역할 - 실제로 인스턴스가 차지할 메모리 공간을 확보함)+생성자(필드값 초기화)

- JRE : 자바 실행환경을 제공하고 라이브러리 및 클래스 로더 등을 포함함. 이 단계에서 JRE에 포함된 것들이 라이브러리와 필요한 resource에 대한 Access를 가능하게 만들고 클래스 로더(JVM에 포함)에 의해 클래스가 실행될 준비를 하게 함
- JVM은 프로그램을 실행하는 역할이고 실행 전에 javac라고 불리는 컴파일러가 컴파일을 하는 것임
- JWT 인증 시 처음에 인증을 위한 토큰을 만들고 이걸로 인증을 하게 됨 성공시 JWT 발급
- Signature에는 암호화된 채로 payload와 header의 내용이 들어감

- JVM - OS로부터 프로그램을 실행시키기 위해 메모리 공간을 빌려와서 관리함 / 여기서 이 메모리 공간을 Runtime Data Area라고 함

빌려온 메모리의 구조(JVM의 메모리구조) - 콜스택(call stack)/Heap

### Heap의 4가지 영역
![Pasted image 20231014195023.png](Concept/README_resources/)
- register : 프로그램에 실행 포인터를 관리(= 컴퓨터가 계산한 코드 실행 흐름에 관한 정보가 관리됨)
- Runtime Contstant Pool : 프로그램 실행시 상수들(final)을 관리하기 위한 영역
위에 두 개는 제어할 수 없는 영역/JVM이 알아서 관리하고 사용하는 영역

- Method Area : 클래스를 사용하는 시점에 클래스에 대한 코드(생성자, 메소드, 필드)가 올라가는 공간/ 딱 한번만 올라가고 반복적으로 사용할 때는 따로 다시 올라가지는 않음
여기에 올라가는 인스턴스 변수 : 인스턴스가 생성되면 해당 변수에 해당 값을 저장해줘 라는 의미로 올라가는 것임 프로그램이 시작되면 가장 먼저 여기에 해당 내용이 올라가게 됨 즉, 설계도는 여기에 올라간다고 할 수 있음
- Heap : 인스턴스의 생성시점에 여기에 저장됨
- Stack : 메소드가 사용되는 순간에 이 안에 공간을 잡고 쌓이게 됨(메소드 내에서 변수(지역변수)나 파라미터(지역변수의 일종)를 위한 메모리 공간이 필요하기 때문에)/메소드 실행종료 시 가장 위에 쌓인 것부터 없어짐

프로그램 시작 시 
1. Method Area에 제일 먼저 클래스에 대한 코드가 올라감(나중에 Method 호출 시 여기에 있는 코드를 보고 호출하는 것) main메소드가 포함된 클래스가 제일 먼저 올라감
2. 메소드를 실행하는 시점에 Stack에 메소드를 위한 공간이 쌓이게 됨 instance 생성 시 호출되는 생성자 역시 호출 시 Stack에 쌓이게 됨

사용할 수 없는 객체 => 사용하고 난 후의 객체
- garbage Collector : 사용할 수 없는 객체(쓰레기)를 수집해서 치우는 친구 -->heap 영역에서 사용하고 난 후의 객체를 지워버림

Stack -> heap -> Method Area 순으로 내용이 비워지게 됨 / 그래서 static이 붙은 애들은 프로그램이 끝나기 전에 없어지는 것임

default 생성자라고 하더라도 호출 시 Stack에 공간은 자리잡게 됨 단, 빈 공간이며 얼마만큼의 byte를 차지하는지는 알 수 없음(가변적이므로/하지만 실제로 일정 byte가 할당되긴 함)

### 클래스의 나머지 개념
Method Overloading : Method의 이름이 같아도 Method의 인자의 개수나 형태가 달라지면 다른 것으로 인식해서 쓸 수 있도록 허용하는 개념 
Constuctor Overloading : Method와 마찬가지로 생성자도 똑같이 Overloading개념이 적용됨
Operator(연산자) Overloading : a = 10 + 30일 때는 덧셈하는 기능으로 쓰지만 a = "안녕" + "하세요" 같은 경우에는 문자열을 붙이는 기능으로 사용(즉, 용도에 따라 기능이 알아서 달라지는 것을 연산자 오버로딩이라고 한다)

Package & import : 원래는 패키지로 나눔으로서 서로 다른 패키지의 클래스는 사용(인지)할 수 없음 
하지만 당연히 클래스는 다른 패키지의 클래스를 사용할 수 있어야 함
+그렇다고 아무데서나 클래스의 요소(필드, 메소드, 생성자)를 다 쓸 수 있도록 해도 문제가 생김
ex)누가 계좌의 잔고(데이터)를 마음대로 0원으로 바꾸는 경우를 예로 들 수 있음
--> 접근 제어자가 그래서 나옴(어디까지 접근할 수 있는지를 제어하는 역할 수행)

### Access Modifier (접근 제어자) 
public(어디서나 사용가능 = 패키지가 달라도 상관없음) - 클래스를 public으로 잡았다고 해서 필드나 메소드, 생성자도 어디서나 사용할 수 있는 것은 아님(얘네들 또한 각각 접근제어자를 지정해서 각각의 범위로 사용해줘야 함)
package(같은 패키지 내에서만 사용가능) - 아무것도 안 써있다면 이 접근제어자가 있다고 생각하면 됨 즉, 정해진 키워드가 없음
위에 2가지 중 하나는 클래스, 생성자, 필드, 메소드 앞에 반드시 등장해야 함(다른 클래스에서 인스턴스를 생성할 경우)

protected - default와 같은 범위를 가지지만 상속관계일 경우에는 Package 상관없이 사용할 수 있게 된다
private - 해당 객체가 가지고 있는 정보가 중요하기 때문에 클래스 외부에서 함부로 바꿀 수 없도록(접근할 수 없도록) 접근제한을 하는 것이 정보은닉 = imformation hiding 
위에 2가지는 클래스 앞에만 못 붙음 `여기서 접근 제한은 ((직접적인 접근))의 제한을 의미함`
- **private 사용이유**
1. 1차적으로는 직접적인 접근을 제한하기 위함(getter/setter를 이용해서 접근해야 된단 얘기)
+ 상속관계에서도 접근 안 됨
2. getter/setter를 통해 private이 붙은 필드, 메소드, 클래스에 접근할 때 조건을 걸 수 있음

클래스의 메소드는 대부분 필드의 제어를 하는 역할을 한다는 것을 알 수 있음

### Class
constructor - constructor overloading 을 통해 일반적으로 여러 개 사용)
field - static field(class variable) --> 결국 여러 인스턴스들이 하나의 변수를 공유하기 위함
         static이 없는 field(instance variable) --> 인스턴스들이 각자 field를 생성(일반적으로          private로 access modifier를 설정 --> information hiding 때문에)
method - 특별한 이유가 없으면 외부에서 사용이 가능하도록 access modifier을 public으로 설정한다.
getter&setter는 business method ==> 직접적인 접근이 어려운 경우 이런 method들을 이용해서 field를 적절하게 변경하거나 특정 로직을 처리하기 위해 사용
'그래서 클래스를 만든다'라는 것은 데이터(field)와 기능(method)을 묶어서 정의하는 것이므로
encapsulation(캡슐화)라고 한다.(객체지향 용어)

JVM안에 class loader이 있음
--> 실제로는 이 친구가 클래스에 대한 정보를 읽음+그리고 Method Area에 해당 정보들을 올림

main()가 포함된 인스턴스를 생성해주지는 않음 그렇다면 어떻게 main()을 실행하는가?
--> 객체 생성없이 사용하려고 static을 붙이는 거임/ 그리고 다른 곳에 있는 JVM에서도 접근이 가능해야 하므로 public을 사용함(그리고 '클래스.' 이것도 안 써도 됨 왜냐하면 다른 클래스에서 main()을 실행하는 것이 아니라 main()가 위치한 클래스 내부에서 실행하기 때문 --> 호출하는 명령문이 따로 없는 이유는 JVM을 통해 실행한다. => main()를 호출한다 이기 때문에)

System.out.println(); 이제 이것도 뭐가 뭔지 알 수 있음
System - 첫글자가 대문자인 걸로 보아 클래스임을 알 수 있음(원래는 앞에서 말한 것처럼 패키지명.을 붙혀주거나 import를 해줘야 쓸 수 있는 게 맞지만 자바에서 알아서 import구문을 넣어주므로 따로 아무것도 안 써도 이렇게 사용이 가능함)
out - 클래스의 생성 없이 호출된 걸 보았을 때 static임을 알 수 있고 괄호가 없으므로 field임을 알 수 있음 + System 안에서 생성된 인스턴스를 가리키는 field임을 알 수 있음
이 필드를 통해 public으로 잡혀있는 println()라는 메소드에 접근

인스턴스변수(field)는 스텍에 메소드를 위한 공간에 생기지 않고 그 공간에 생기는 참조변수를 통해 접근하게 되는 것임
