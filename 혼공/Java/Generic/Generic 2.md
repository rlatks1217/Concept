### Generic Type
결정되지 않은 타입을 파라미터로 가지는 클래스와 인터페이스를 말함
- `<T>`(타입 파라미터)는 `<A, B, C>`와 같은 형태로 여러 개를 사용할 수도 있음
```java
public class 클래스명<A, B, C> { . . . }
public interface 인터페이스명<A, B, C> { . . . }
```
- 인터페이스의 경우 implements할 때 구체적인 타입을 지정할 수 있음 (해당 인터페이스 안에 추상 메소드는 당연히 지정된 타입대로 오버라이딩 해줘야 함)
- `<T>`에 아무런 구체적인 타입을 지정하지 않을 시, 기본적으로 Object Type으로 간주됨
-> 그래서 기본적으로 equals()와 같이 Object클래스 소속의 메소드를 사용할 수 있음

이때, 내부의 필드에 할당되는 객체의 타입이 Object 클래스의 메소드를 오버라이딩한 클래스인 경우 오버라이딩한 메소드가 호출됨
```java
Box box = new Box(); // 아무런 구체적인 타입도 지정하지 않음
Box.content = "String"; // String 객체를 내부 필드에 할당

// Object클래스를 상속하고 있는 String클래스는 Object의 equals()를 오버라이딩함
// 그래서 box.equals() 호출 시 String 클래스의 equals() 즉, 오버라이딩한 equals()가 호출될 것임 
```

- 매개변수 타입이나 return타입에 `<super T>` 와 같은 제네릭이 올 경우 T자리의 오는 클래스의 부모 타입도 올 수 있다는 의미

### Generic의 또다른 기능
![](../../../README_resources/Pasted%20image%2020231018172051.png)
Generic이 있기 전에는 이처럼 아무 DataType이나 넣어도 에러가 안 남 
=> 잘못된 DataType이 들어가도 잡을 수 없음 
=> 하지만 Generic이 생긴 후부터는 원하는 데이터 타입만 집어넣을 수 있게 되었음

또한, 원래는 add()를 사용할 때마다 `list.add((Integer)10);` 와 같이 형변환을 해주고 넣어줬어야 함 하지만, 컴파일러가 알아서 형변환을 해주므로 형변환 과정을 생략하고 사용하던 것임

### 사용 사례
- 객체의 값(내용)을 비교하는 메소드가 선언된 클래스가 있다고 할 때 Generic이 없다면 비교하는 객체 타입에 따라 다루는 데이터의 타입만 다른 똑같은 내용의 메소드를 계속 새로 선언해줘야 함. (낭비임)
- 하지만 Generic을 사용함으로써 그럴 필요가 없어지게 되었음(생성 시 사용하는 데이터 타입만 지정해주면 되니까)

- 위의 사례는 비교하는 객체가 Integer나 String과 같이 내부적으로 equals()를 내용 비교하도록 오버라이딩한 클래스 타입이 아닐 때의 얘기임