- 디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미함

### 생성 패턴
1. 추상 팩토리 : 인터페이스의 구현체들을 조합하여 새로운 객체를 생성함
2. 빌더 : 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성함
3. 팩토리 메소드 : 상위 클래스에서는 인터페이스만 정의하고  하위 클래스에서 구현하는 생성함(이것을 통해서 만든 객체들을 조합하여 객체를 생성하는 패턴이 추상 팩토리 패턴임)
4. 프로토타입 /싱글톤 : 설명 생략

### 구조 패턴
1. 어댑터 : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
2. 브리지 : 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
3. 컴포지트 : 여러객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
4. 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능들을 확장 할 수 있는 패턴
5. 퍼싸드 : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함
6. 플라이웨이트 : 인스턴스가 필요할 때마다 매번 생성하는 것이 아니라 가능한 공유해서 사용
7. 프록시 : 접근이 어려운 객체와 해당 객체에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

### 행위 패턴
1. 책임 연쇄 : 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
2. 커맨드 : 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나로그에 남기는 패턴
3. 인터프리터 : 언어의 문법 표현을 정의하는 패턴
4. 반복자 : 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
5. 중재자 : 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
6. 메멘토 : 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 해당 시점의 상태로 되돌릴 수 있는 기능을 제공하는 패턴
7. 옵서버 : 한 객체가 변하면 다른 객체에도 변화된 상태를 전달하는 패턴
8. 상태 : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용
9. 전략 패턴 : 말 그대로 전략을 계속 다르게 쓰는 것마냥 여러 알고리즘들을 개별적으로 캡슐화하여 바꿔쓸 수 있게 정의하는 패턴
10. 템플릿 메소드 패턴 : 기능(로직)의 큰 틀은 정해져 있지만 세부적인 부분만 변경이 가능할 수 있도록 큰 틀만 추상화하고 나머지는 하위 클래스에서 구체화하는 패턴