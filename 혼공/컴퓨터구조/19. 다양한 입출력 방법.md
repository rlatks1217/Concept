세 가지 입출력 방식 : 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력

### 프로그램 입출력
- 입출력장치에 연결된 장치 컨트롤러를 프로그램 속 명령어로 제어하는 방법
Ex) 
메모리에 저장된 정보를 하드디스크에 백업(하드디스크에 새로운 정보 쓰기 작업)을 한다고 했을 때의 과정
1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 내보내기
2. 하드 디스크 컨트롤러는 하드 디스크의 상태를 확인 -> 상태 레지스터에 준비 완료 상태를 표시함
3. 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 씀
-  CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인

이 과정을 백업 작업이 끝날 때까지 반복하게 됨

그런데 CPU는 장치 컨트롤러 레지스터들의 주소를 알 수 있을까?

### 메모리 맵 입출력
- 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나 주소 공간으로 간주하는 방법
- 하나의 공간을 나눠서 쓰는 방식이기 때문에 메모리 주소 공간이 입출력 장치 주소 공간만큼 줄어듦
- 주소 공간 : CPU가 접근할 수 있는 주소들이 모여 있는 공간

07:10 사진 첨부

Ex) 
- 516번지 : 프린터 컨트롤러의 데이터 레지스터
- 517번지 : 프린터 컨트롤러의 상태 레지스터
- 518번지 : 하드 디스크 컨트롤러의 데이터 레지스터
- 519번지 : 하드 디스크 컨트롤러의 상태 레지스터

라고 가정했을 때 `517번지를 읽어라` 라는 명령어를 실행하면 프린터 상태 레지스터에 접근하여 `프린터 상태 읽기`를 수행하는 것
단, 하나의 주소 공간을 나눠서 사용하기 때문에 하드 디스크든 프린터든 똑같이 생긴 명령어로 명령을 실행시킬 수 있음

### 고립형 입출력
- 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하여 관리하는 방법(메모리 맵 입출력과 반대)
- 입출력 전용 명령어를 따로 사용함

11:45 사진 첨부

12:50 사진 첨부

### 인터럽트 기반 입출력
- 하드웨어 인터럽트는 사실 장치 컨트롤러에 의해 발생함
- 앞서 설명한 것처럼 CPU가 주기적으로 상태 레지스터를 확인하는 것이 아니라 CPU가 입출력 장치에 작업 요청을 보내면 장치 컨트롤러가 CPU에게 준비 완료 신호(인터럽트 요청)를 알리게 됨 -> CPU는 주기적으로 상태 레지스터를 확인할 시간에 다른 작업을 할 수 있게 됨

##### 폴링
- 입출력 장치의 상태는 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 방식
- 폴링 방식은 당연히 인터럽트 방식보다 CPU에 부담이 더 많이 됨





