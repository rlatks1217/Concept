 세 가지 입출력 방식 : 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력

### 프로그램 입출력
- 입출력장치에 연결된 장치 컨트롤러를 프로그램 속 명령어로 제어하는 방법
Ex) 
메모리에 저장된 정보를 하드디스크에 백업(하드디스크에 새로운 정보 쓰기 작업)을 한다고 했을 때의 과정
1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 내보내기
2. 하드 디스크 컨트롤러는 하드 디스크의 상태를 확인 -> 상태 레지스터에 준비 완료 상태를 표시함
3. 하드 디스크가 준비되었다면 CPU는 백업할 메모리의 정보를 데이터 레지스터에 씀
-  CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인

이 과정을 백업 작업이 끝날 때까지 반복하게 됨

그런데 CPU는 어떻게 장치 컨트롤러 레지스터들의 주소를 알 수 있을까?

### 메모리 맵 입출력
- 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나 주소 공간으로 간주하는 방법
- 하나의 공간을 나눠서 쓰는 방식이기 때문에 메모리 주소 공간이 입출력 장치 주소 공간만큼 줄어듦
- 주소 공간 : CPU가 접근할 수 있는 주소들이 모여 있는 공간

![](../../README_resources/Pasted%20image%2020240317143316.png)

Ex) 
- 516번지 : 프린터 컨트롤러의 데이터 레지스터
- 517번지 : 프린터 컨트롤러의 상태 레지스터
- 518번지 : 하드 디스크 컨트롤러의 데이터 레지스터
- 519번지 : 하드 디스크 컨트롤러의 상태 레지스터

라고 가정했을 때 `517번지를 읽어라` 라는 명령어를 실행하면 프린터 상태 레지스터에 접근하여 `프린터 상태 읽기`를 수행하는 것
단, 하나의 주소 공간을 나눠서 사용하기 때문에 하드 디스크든 프린터든 똑같이 생긴 명령어로 명령을 실행시킬 수 있음

### 고립형 입출력
- 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하여 관리하는 방법(메모리 맵 입출력과 반대)
- 입출력 전용 명령어를 따로 사용함

![](../../README_resources/Pasted%20image%2020240317143353.png)

![](../../README_resources/Pasted%20image%2020240317143426.png)

### 인터럽트 기반 입출력
- 하드웨어 인터럽트는 사실 장치 컨트롤러에 의해 발생함
- 앞서 설명한 것처럼 CPU가 주기적으로 상태 레지스터를 확인하는 것이 아니라 CPU가 입출력 장치에 작업 요청을 보내면 장치 컨트롤러가 CPU에게 준비 완료 신호(인터럽트 요청)를 알리게 됨 -> CPU는 주기적으로 상태 레지스터를 확인할 시간에 다른 작업을 할 수 있게 됨

##### 폴링
- 입출력 장치의 상태는 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 방식
- 폴링 방식은 당연히 인터럽트 방식보다 CPU에 부담이 더 많이 됨

### CPU가 동시다발적인 인터럽트를 처리하는 방식
1. 인터럽트가 발생한 순서대로 처리하는 방식 
- 하지만 늦게 일어난 인터럽트가 우선순위가 높은 경우에는 일어난 순서대로 처리되선 안 됨
- 기본적으로는 인터럽트가 발생한 순서대로 처리 But NMI(**N**on **M**askable **I**nterrupt) 같은 경우에는 순서고 자시고 필요없이 NMI를 먼저 처리하게 됨
- 일반적으로 사용하는 방식은 아님

![](../../README_resources/Pasted%20image%2020240317175138.png)

2. 우선순위를 반영한 인터럽트 처리 방식 
- 인터럽트 B의 우선순위가 인터럽트 A보다 높다면 B가 더 늦게 발생해도 B를 먼저 실행하게 됨
- 일반적으로 사용하는 방식임

![](../../README_resources/Pasted%20image%2020240317175235.png)

![](../../README_resources/Pasted%20image%2020240317180003.png)

![](../../README_resources/Pasted%20image%2020240317180049.png)

- 이렇게 장치 컨트롤러와 CPU의 중간에서 어떤 인터럽트가 우선적으로 처리되어야 하는지 판단하여 CPU에게 알려줌

### DMA(Direct Meomory Access) 입출력
- 보통 입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고 이동하는 데이터도 반드시 CPU를 거치게 됨
Ex) 하드 디스크(= 입출력 장치)의 데이터를 메모리에 저장한다고 했을 땐 다음과 같은 과정을 따름
1. 입출력 장치의 데이터를 CPU가 읽고 CPU의 레지스터에 저장함
2. 레지스터에 저장된 데이터를 메모리 쓰기 신호를 통해 메모리에 저장함

- DMA : CPU를 거치지 않고 입출력 장치가 메모리에 직접적으로 접근하는 기능

### DMA 입출력 과정
1. CPU는 DMA 컨트롤러에 입출력 작업을 명령함
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에게 작업이 끝났음을 알림
- CPU는 결국 입출력 작업이라는 일련의 과정에서 시작과 끝만 관여하면 됨 -> 효율적
- DMA 컨트롤러는 입출력 작업을 하기 위해서 시스템 버스를 이용해야 하는데 시스템 버스를 이용하는 방식은 아래의 두 가지가 있음
1. CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스를 이용하는 방식
2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 이용하는 방식

![](../../README_resources/Pasted%20image%2020240317183648.png)

### 입출력 버스
- 입출력 작업 시 입출력 장치들은 입출력 버스를 따로 연결하여 사용하게 됨
-> 불필요하게 시스템 버스를 여러 번 거칠 필요가 없음(시스템 버스를 공유해서 사용하는 자원이기 때문에 CPU도 다른 작업을 위해 사용해야 됨. 그래서 입출력 작업을 위한 데이터들이 시스템 버스를 자주 왔다갔다 하는 것은 좋지 않은 것)

#### 입출력 버스 사용 전
 
![](../../README_resources/Pasted%20image%2020240317184137.png)
1. 메모리로부터 읽을 때
2. 하드디스크(입출력 장치)에 쓸 때

![](../../README_resources/Pasted%20image%2020240317184536.png)

