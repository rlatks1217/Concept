### 명령어 파이프 라인
- 명령어가 처리되는 과정을 비슷한 시간 간격으로 나누면?
1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장
와 같은 단계를 거쳐서 처리가 될 것임(전공서에 따라 `인출 -> 처리` 로만 나누는 경우도 있음)

- 여기서 단계가 아니라면 CPU는 `각 단계를 동시에 실행할 수 있다.`
 -> CPU는 명령어 1을 해석하면서 명령어 2를 인출할 수 있다는 얘기임. 
 - 이런  식으로 동시에 여러 개의 명령어를 겹쳐서 처리하는 것을 **명령어 파이프라이닝**이라고 함.

![](../../README_resources/Pasted%20image%2020240116075742.png)

### 파이프라인 위험(잠재적인 위험)
-  명령어 파이프라인이 성능 향상에 실패하는 경우 즉, 병렬적으로 처리될 수 없는 경우를 말함

1. 데이터 위험 : 명령어 간의 의존성에 의해 야기됨. 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우를 예로 들 수 있음
Ex) 
명령어 1 : R1 = R2 + R3
명령어 2 : R4 = R1 + R5

와 같이 명령어 1의 결과 즉, R1이 완성되어 있어야 명령어 2가 실행될 수 있는 경우가 있을 수 있음

2. 제어 위험 : JUMP 명령어를 실행하는 것과 같이 프로그램 카운터의 갑작스러운 변화(다음으로 실행될 명령어의 주소가 변경됨을 의미)에 의해 야기됨

3. 구조적 위험 : 서로 다른 명령어를 실행시키는 과정에서 같은 CPU 부품(ALU, 레지스터)를 쓰려고 할 때 발생함

### 슈퍼스칼라
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 같은 단계를 동시에 여러 번 실행할 수 있는 구조(멀티 쓰레드에서 가능할 것임)
- 이론적으로는 파이프 라인 개수에 비례해서 처리 속도가 증가하지만 실제로는 위에서 언급한 파이프라인 위험의 증가로 인해 그렇지 않음

![](../../README_resources/Pasted%20image%2020240116075914.png)

### 비순차적 명령어 처리(OOOE)
- 파이프라인의 중단을 막기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법

파이프라인 중단 상황 ↓↓↓↓↓


![](../../README_resources/Pasted%20image%2020240116075441.png)
![](../../README_resources/Pasted%20image%2020240116075511.png)

위의 사진들에 나온대로 명령어 간의 순서를 바꾼다면 파이프라인을 유지하면서 실행이 가능하게 됨(효율적으로 동작 가능)

당연히 아무 명령어나 순서를 바꿀 수는 없고, 실행 결과에 영향이 없는 경우에만 바꿀 수 있음(아래 예시 참고)

![](../../README_resources/Pasted%20image%2020240116075951.png)
