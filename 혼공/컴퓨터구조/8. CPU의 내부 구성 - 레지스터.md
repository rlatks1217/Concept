- 레지스터는 CPU 내부의 작은 임시저장장치
- 프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장됨
- CPU 내부에는 다양한 레지스터들이 있고, 각각의 역할이 다름

### 반드시 알아야 할 레지스터
**1. 프로그램 카운터 : 메모리에서 가져올(읽어들일) 명령어의 주소를 저장함**
- 특정 명령어가 실행중이라면 해당 명령어 실행이 끝나고 실행할 명령어의 주소를 저장한다는 의미(첫 번째로 실행할 명령어의 주소도 일단 여기에 저장되고 시작함)
- 프로그램 카운터를 Intruction Pointer라고 지칭하는 CPU도 존재함

**2. 메모리 주소 레지스터 : 메모리의 주소를 저장함**
- 프로그램 카운터에 저장했던 주소가 여기에 복사되고 주소 버스를 통해 메모리 읽기 신호와 함께 주소를 보내서 읽게 됨

**3. 메모리 버퍼 레지스터 : 메모리와 주고받을 값을 저장함(CPU가 정보를 데이터 버스를 이용하여 주고 받을 때 사용되는 레지스터)**
- 메모리 읽기 신호를 보내서 읽은 명령어는 여기에 저장됨
- 이때, 프로그램 카운터에 저장되어 있던 주소도 다음 실행할 명령어의 주소로 새로 저장됨 

**4. 명령어 레지스터 : 해석할 명령어(방금 메모리에서 읽어 들인 명령어)를 저장함**
- 메모리 버퍼 레지스터에 있던 명령어를 여기에 저장하게 됨
##### 동작과정
1. 프로그램 카운터에 실행될 명령어의 주소가 저장됨
2. 메모리 주소 레지스터에 이 주소를 복사한 후, 주소 버스를 통해 메모리 읽기 신호와 함께 보내서 해당 명령어를 읽게 됨
3. 데이터 버스를 통해 명령어를 받아서 메모리 버퍼 레지스터에 저장함. 이때, 프로그램 카운터에 저장되어 있던 주소가 지금 메모리 버퍼 레지스터에 저장되어 있는 명령어 다음으로 실행될 명령어의 주소로 새로 저장됨
4. 명령어를 해석하기 위해서 메모리 버퍼 레지스터에 있던 명령어를 명령어 레지스터에 옮겨담음

다음과 같은 동작과정을 보았을 때 명령어는 보통 순차적으로 실행됨을 알 수 있음
단, 특정 메모리 주소로 실행 흐름을 이동하는 명령어(ex - JUMP)를 실행하거나 인터럽트 발생 등의 상황에서는 순차적인 실행 흐름이 끊기게 됨
****
**5. 플래그 레지스터 : 연산 결과 또는 CPU 상태에 대한 부가정보를 저장함**

**6. 범용 레지스터 : 다양하고 일반적인 상황에서 사용자의 필요에 따라 자유롭게 사용할 수 있는 레지스터임(보통 여러 개 있음)**

**7. 스택 포인터 : 스택이 어디까지 차 있는지에 대한 정보를 가지고 있는 레지스터**
- 스택 주소 지정 방식에 사용됨
- 스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택에 새로 정보가 쌓이거나 빠지면 그에 따라 업데이트됨

**8. 베이스 레지스터 : 변위 주소 지정 방식에 사용되는 레지스터**
- 변위 주소 지정 방식 : 오퍼랜드 필드의 값(변위라고 함)과 특정 레지스터의 값을 **더하여** 유효 주소를 얻는 방식(앞에서 나온 주소 지정 방식 외에 이런 주소 지정 방식도 있다 라고만 이해하고 넘어가기)
14:40초 사진 첨부
- 여기서 특정 레지스터에는 프로그램 카운터, 베이스 레지스터가 해당함
- 변위 주소 지정 방식의 종류
	1. 상대 주소 지정 방식 : 오퍼랜드 필드의 값과 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

- 오퍼랜드 필드에는 얼마나 떨어져 있는지에 대한 값이 담기는 것을 알 수 있음
	2.  베이스 레지스터 주소 지정 방식 : 오퍼랜드 필드의 값과 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식(즉 , 기준 주소로부터 얼마나 떨어져 있는지 계산하여 필요한 데이터의 위치를 찾아내는 것)
		- 베이스 레지스터에는 프로그램의 시작 주소와 같은 기준이 되는 주소가 담김
  
