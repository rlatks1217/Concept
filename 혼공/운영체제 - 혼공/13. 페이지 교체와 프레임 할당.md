- 운영체제는 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고, 프로세스들에게 적절한 수의 프레임을 할당해야 함
### 요구 페이징
- 처음부터 모든 페이지를 적재하지 않고 **요구되는 페이지만** 적재하는 것을 말함
**요구 페이징이 실행되는 양상**
1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근함
3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생함
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리에 적재하고 유효 비트를 1로 바꿈
5. 다시 1번 과정부터 실행함

※ **순수 요구 페이징** : 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 하는 것을 말함
이 경우에는 첫 번째 페이지를 실행할 때부터 페이지 폴트가 계속 발생하다가 실행을 시작하고 일정 시점이 지난 이후부터는 페이지 폴트가 일어나지 않는 양상을 보일 것

### 페이지 교체 알고리즘
- 요구 페이징 기법으로 페이지들을 추가적으로 적재하다 보면 언젠가는 메모리가 가득 차게 될 것임 
-> 메모리가 가득차고 나서 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지 중 어떤 페이지를 보조기억장치로 내보내야 할까? 를 결정하는 방법이 **페이지 교체 알고리즘**
####  좋은 페이지 교체 알고리즘이란?
- 페이지 폴트가 적은 알고리즘(페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하) -> 페이지 폴트가 자주 발생한다는 것은 보조기억장치로 내보내야 할 페이지를 잘못 고르고 있음을 의미함
- 페이지 폴트가 자주 발생하는지 알기 위해서는 페이지 폴트의 횟수를 알아야 함 
-> 이를 알기 위해 사용되는 것이 페이지 참조열(page reference string)
- **페이지 참조열** : CPU가 참조할 페이지들 중 연속된 페이지를 생략한 페이지열
(요구 페이징 기법을 사용할 경우 특정 페이지에 처음 참조하게 되는 시점에선 메모리에 해당 페이지가 없기 때문에 페이지 폴트가 발생할 것임 -> 즉, 페이지 참조열에 있는 페이지들은 무조건 페이지 폴트가 발생했던 페이지들이라고 할 수 있음)

```
2 2 2 3 5 5 5 3 3 7
```
CPU가 참조한 페이지가 다음과 같다면 페이지 참조열은 아래와 같음
```
2 3 5 3 7
```
연속된 페이지를 생략하는 이유는 만일 2페이지를 처음 참조했을 때 2페이지가 메모리에 없어서 페이지 폴트가 발생했다면 그 다음에 2페이지를 참조할 땐 페이지 폴트가 처리된 후일 것이고, 그렇다면 페이지 폴트가 발생하지 않을 것이므로 생략해도 무방한 것임

## 페이지 교체 알고리즘
### FIFO 페이지 교체 알고리즘
- 가장 오래 적재되어 있던 페이지를 보조기억장치로 내보내는 페이지 교체 알고리즘
- 아래 예시(그림)에서는 페이지가 처음 적재될 때 발생하는 페이지 폴트는 고려하지 않음

![](../../README_resources/Pasted%20image%2020240503063624.png)

- 프로그램 실행 내내 실행될 페이지에 경우 내보내선 안 되지만 위 알고리즘에서는 내보내기 때문에 그렇게 좋은 알고리즘은 아님
- FIFO 페이지 교체 알고리즘 - 보완책
	- **2차 기회(second-chance) 페이지 교체 알고리즘**
	- 참조 비트 1 : CPU가 한 번 참조한 적 있는 페이지
	- 참보 비트 0 : CPU가 참조한 적이 없는 페이지
	- 참조 비트가 1이라면 적재된 시점은 현재로 설정(가장 최근에 적재되었다고 간주)하고 맨 뒤에 있던 해당 페이지를 맨 앞으로 다시 보냄(한 번 더 기회를 주는 것임)
	- 참조 비트가 0이라면 가장 오래되었지만 참조된 적이 없는 페이지이므로 보조기억장치로 내보냄

### 최적 페이지 교체 알고리즘
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 페이지 교체 알고리즘
- 위의 예시(그림)와 마찬가지로 페이지가 처음 적재될 때 발생하는 페이지 폴트는 고려하지 않음

![](../../README_resources/Pasted%20image%2020240503065658.png)

- 가장 낮은 페이지 폴트율을 보장하는 페이지 겨체 알고리즘
- But 사용되지 않을 페이지를 예측하기는 어렵기 때문에 구현이 어려움
#### 보안책 - LRU(Least-Recently-Used) 페이지 교체 알고리즘
- 최적 페이지 교체 알고리즘과는 다르게 가장 오래 사용되지 않는 페이지를 교체하는 알고리즘
- `최근에 사용되지 않는 페이지는 앞으로도 사용하지 않지 않나?` 라는 생각에서 출발

![](../../README_resources/Pasted%20image%2020240507073718.png)

**페이지 폴트가 자주 발생하는 또다른 이유 : 프로세스가 사용할 수 있는 프레임 자체가 적어서임(이게 더 근본적인 이유임)**

### 스레싱과 프레임 할당
- 스레싱 : 프로세스가 **실행되는 시간보다 페이징에 더 많은 시간을 소요**하여 CPU이용률이 저해하는 문제를 말함

![](../../README_resources/Pasted%20image%2020240508070919.png)

![](../../README_resources/Pasted%20image%2020240507074048.png)

- CPU 이용률이 급속도로 떨어지는 부분이 스레싱이 발생하는 부분임 -> 동시의 실행되는 프로세스가 많다고 해서 CPU 이용률이 무조건적으로 좋은 게 아닌 것을 알 수 있음 
- 스레싱의 발생 원인 : 각 프로세스가 필요로 하는 최소한의 프레임 수를 보장하지 않았기 때문에 발생함 -> 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 함

#### 균등할당
- 가장 단순한 할당 방식
- 모든 프로세스에게 균등하게 프레임을 할당하는 방식
- 실행되는 프로세스의 크기는 각각 다르기 때문에 모든 프로세스에 동일한 프레임 수를 할당하는 것은 권장되는 방식이 아님

#### 비례할당
- 프로세스 크기에 비례하여 프레임을 할당
- 비례할당과 균등할당은 프로세스의 실행과정은 고려하지 않고 고정 크기만을 고려하는 방식이기 때문에 정적 할당 방식이라고 함(결국 프로세스가 필요로 하는 프레임 수는 실제로 실행해봐야 알 수 있음)

#### 작업 집합 모델(Working Set Model)
- 프로세스가 실행되는 동안 배분할 프레임을 결정
- CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당
- 작업 집합 : 실행 중인 프로세스가 일정시간 동안 참조한 페이지의 집합

Ex) 특정 프로세스가 3초간 7개의 프레임에 참조했다고 하면 앞으로의 3초라는 시간 동안은 7개의 프레임을 할당하게 되는 것임

작업 집합을 구하려면 아래 두 가지가 필요함
1. 프로세스가 참조한 페이지
2. 시간 간격

![](../../README_resources/Pasted%20image%2020240508071254.png)

#### 페이지 폴트 빈도 모델(Page Fault Frequency Model)
- 프로세스가 실행하는 과정에서 배분할 프레임을 결정

페이지 폴트 빈도는 아래 두 가지 가정에서 탄생함
1. 페이지 폴트율이 너무 높으면 프로세스가 너무 적은 프레임을 가지고 있음을 의미
2. 페이지 폴트율이 너무 낮으면 프로세스가 너무 많은 프레임을 가지고 있음을 의미

![](../../README_resources/Pasted%20image%2020240508071337.png)

- 위 그래프에서 상한선일 경우에는 프레임을 더 할당하고 하한선일 경우에는 프레임을 회수하게 됨 -> 즉, 상한선과 하한선을 정하고 그 내부 범위 안에서만 프레임을 할당
- 작업 집합 모델과 페이지 폴트 빈도를 이용하여 프레임을 할당하는 것을 동적 할당 방식이라고 함

